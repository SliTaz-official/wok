#!/bin/sh
# Tazbb - SliTaz Build Bot.
# System wide config file: /etc/slitaz/tazbb.conf
#
# Tazbb is a tool to automate package building, it can be run manually
# or via a cron job. On SliTaz build host, tazbb is run in a chroot env.
#
# (c) 2009 SliTaz GNU/Linux project - GNU gpl v3
#

# Include config file or exit if no file found.
if [ -f "./tazbb.conf" ]; then
	. ./tazbb.conf
elif [ -f "/etc/slitaz/tazbb.conf" ]; then
	. /etc/slitaz/tazbb.conf
else
	echo -e "\nNo config file found: tazbb.conf...\n" && exit 0
fi

# Tazbb is only for root.
if test $(id -u) != 0 ; then
   echo -e "\nYou must be root to run: `basename $0`.\n" && exit 0
fi

# Let tazbb finish is work and make sure needed files exist.
if [ -f $LOCK_FILE ]; then
	case $1 in
		usage|list-*|*block)
			continue ;;
		*)
			echo -e "\nTazbb is already running and locked...\n"
			exit 0 ;;
	esac
else
	mkdir -p $DB_DIR $LOG_DIR
	touch $LOCK_FILE $DB_DIR/blocked
fi

# Set KERNEL variable
if [ -s $BUILD_WOK/linux/receipt ]; then
	. $BUILD_WOK/linux/receipt
	KERNEL=$VERSION
fi

usage()
{
	echo -e "\nSliTaz developers and build host tool\n
\033[1mUsage: \033[0m `basename $0` [command] [--option]
\033[1mCommands: \033[0m\n
  usage        Print this short usage and command list.
  list-pkgs    List last cooked packages with date.
  report       Run in report mode and dont cook anything [--verbose].
  cook         Cook, install and log a single package build.
  cook-all     Cook all missing, modified or unbuilt packages.
  cook-commit  Cook all packages affected by a commit in the last update.
  test-pkgs    Execute a test suite on all packages [--verbose].
  [un]block    Block or unblock a package to skip or enable building.
  mail         Send mail to package maintainer with tazbbmail.
  clean-up     Remove old packages [--verbose|--dry-run].
  clean-log    Remove all generated build log files.\n"
}

status()
{
	local CHECK=$?
	echo -en "\033[70G"
	if [ $CHECK = 0 ]; then
		echo "Done"
	else
		echo "Failed"
	fi
	return $CHECK
}

top_summary()
{
	cat > $DB_DIR/summary << _EOT_
Update   : `date`
Revision : $NEW_REV (<a href="$HG_URL/log/$NEW_REV">changelog</a>)
_EOT_
}

packages_summary()
{
	if ! grep -q "^Packages" $DB_DIR/summary; then
		cat >> $DB_DIR/summary << _EOT_
Packages : `ls $BUILD_WOK | wc -l` in the wok, `cat $DB_DIR/cooklist | wc -l` to cook, \
`cat $DB_DIR/blocked | wc -l` blocked, `cat $DB_DIR/corrupted | wc -l` corrupted
_EOT_
	fi
}

packages_summary_update()
{
	sed -i s/"[0-9]* in the wok"/"`ls $BUILD_WOK | wc -l` in the wok"/ \
		$DB_DIR/summary
	sed -i s/"[0-9]* to cook"/"`cat $DB_DIR/cooklist | wc -l` to cook"/ \
		$DB_DIR/summary
	sed -i s/"[0-9]* blocked"/"`cat $DB_DIR/blocked | wc -l` blocked"/ \
		$DB_DIR/summary
	sed -i s/"[0-9]* corrupted"/"`cat $DB_DIR/corrupted | wc -l` corrupted"/ \
		$DB_DIR/summary
}

list_packages()
{
	cd $PACKAGES_REPOSITORY
	ls -1t *.tazpkg | head -20 | \
	while read file
	do
		echo -n $(stat -c '%y' $PACKAGES_REPOSITORY/$file | cut -d. -f1)
		echo "   $file"
	done
}

show_report()
{
	echo "Cooklist"
	echo "================================================================================"
	cat $DB_DIR/cooklist && echo ""
	echo "Packlist"
	echo "================================================================================"
	cat $DB_DIR/packlist && echo ""
	echo "Blocked"
	echo "================================================================================"
	cat $DB_DIR/blocked && echo ""
	echo ""
}

# URL encoding
escape()
{
	echo $1 | sed -e 's/+/%2B/g' -e 's|/|%2F|g' -e 's/:/%3A/g'
}

update_wok()
{
	local forced
	forced=""
	echo ""
	echo "(updating flavors)" > $DB_DIR/running
	cd $HG_FLAVORS
	LAST_REV=`hg head --template '{rev}\n'`
	hg pull && hg update
	NEW_REV=`hg head --template '{rev}\n'`
	if [ "$NEW_REV" != "$LAST_REV" ]; then
		size=`du -sh $HG_FLAVORS | awk '{ print $1 }'`
		echo -n "Copying Hg flavors to the build flavors ($size)... "
		cp -a $HG_FLAVORS/* $BUILD_FLAVORS
		cp -a $HG_FLAVORS/.hg $BUILD_FLAVORS
		echo -e "Done\n"
		forced="yes"
	fi
	echo "(updating wok)" > $DB_DIR/running
	cd $HG_WOK
	LAST_REV=`hg head --template '{rev}\n'`
	hg pull && hg update
	NEW_REV=`hg head --template '{rev}\n'`
	# Gen a new summary and link last revision for the web interface.
	echo -e "\nHg wok    : $HG_WOK ($NEW_REV)"
	echo -e "Build wok : $BUILD_WOK ($LAST_REV)\n"
	top_summary
	# Copy Hg wok if new revision or exit to stop process since nothing
	# have change (--forced can be used).
	if [ "$NEW_REV" != "$LAST_REV" ]; then
		size=`du -sh $HG_WOK | awk '{ print $1 }'`
		echo -n "Copying Hg wok to the build wok ($size)... "
		#rsync -r -n -t $HG_WOK/ $BUILD_WOK/
		cp -a $HG_WOK/* $BUILD_WOK
		cp -a $HG_WOK/.hg $BUILD_WOK
		echo -e "Done\n"
	else
		if [ "$1" = "cook-all" ] || [ "$1" = "cook-commit" ]; then
			if [ "$2" != "--forced" -a -z "$forced" ]; then
				echo -e "Nothing to cook...\n"
				packages_summary
				rm -f $LOCK_FILE && exit 0
			fi
		fi
	fi
}

# Running 'tazbb report' should not pack anything and --verbose option
# can be used to display more messages.
check_flavors()
{
	# Clean up last results.
	rm -f $DB_DIR/packlist && touch $DB_DIR/packlist
	echo ""
	echo "Checking all files in: $HG_FLAVORS"
	echo "================================================================================"
	echo "(checking flavors)" > $DB_DIR/running
	for flavor in $(cd $HG_FLAVORS ; ls)
	do
		[ "$2" = "--verbose" ] && echo "Flavor : $flavor"
		if [ ! -s $PACKAGES_REPOSITORY/$flavor.flavor ]; then
			echo $flavor >> $DB_DIR/packlist
			[ "$1" = "report" ] && echo "Missing : $flavor"
			echo "Missing flavor : $flavor" >> $DB_DIR/report
			continue
		fi
		for i in $(find $HG_FLAVORS -type f); do
			[ $PACKAGES_REPOSITORY/$flavor.flavor -nt \
			  $i ] && continue
			echo $flavor >> $DB_DIR/packlist
			[ "$1" = "report" ] && echo "Refresh : $flavor"
			echo "Refresh flavor : $flavor" >> $DB_DIR/report
			continue 2
		done
		[ -s $HG_FLAVORS/$flavor/packages.list ] &&
		for i in $(cat $HG_FLAVORS/$flavor/packages.list); do
			[ $PACKAGES_REPOSITORY/$flavor.flavor -nt \
			  $BUILD_WOK/$i/taz ] && continue
			echo $flavor >> $DB_DIR/packlist
			[ "$1" = "report" ] && echo "Repack : $flavor"
			echo "Repack flavor : $flavor" >> $DB_DIR/report
			continue 2
		done
	done
}

# Here we pack all flavors found in the packlist.
pack_flavors()
{
	[ -s $DB_DIR/packlist ] || return
	[ $PACKAGES_REPOSITORY/packages.list -nt /var/lib/tazpkg/packages.list ] &&
	cp -a $PACKAGES_REPOSITORY/packages.list /var/lib/tazpkg/packages.list
	cd $PACKAGES_REPOSITORY
	for flavor in $(cat $DB_DIR/packlist)
	do
		tazlito pack-flavor $flavor
		# Remove flavor from the packlist and empty lines for HTML <pre>.
		sed -i /"^$flavor$"/d $DB_DIR/packlist
		sed -i '/^$/d' $DB_DIR/packlist
	done
	cd - > /dev/null
}

# Running 'tazbb report' should not cook anything and --verbose option
# can be used to display more messages.
check_wok()
{
	# Clean up last results.
	rm -f $DB_DIR/cooklist && touch $DB_DIR/cooklist
	rm -f $DB_DIR/report && touch $DB_DIR/report
	rm -f $DB_DIR/unbuilt && touch $DB_DIR/unbuilt
	echo "Checking all files in: $HG_WOK"
	echo "================================================================================"
	echo "(checking wok)" > $DB_DIR/running
	for pkg in $HG_WOK/*
	do
		EXTRAVERSION=""
		WANTED=""
		. $pkg/receipt
		[ "$2" = "--verbose" ] && echo "Package : $PACKAGE"
		# Skip blocked packages.
		if grep -qs "^$PACKAGE$" $DB_DIR/blocked; then
			echo "Blocked : $PACKAGE ($VERSION)" && continue
		fi

		# Some packages may compute VERSION at cook time (bristuff)
		if grep -q ^get_version $pkg/receipt; then
			. $BUILD_WOK/$PACKAGE/taz/*/receipt
		fi

		# First check if package exit. Package naming _must_ be in the form of:
		# $PACKAGE-$VERSION or $PACKAGE-${VERSION}$EXTRAVERSION (Kernel string).
		if [ ! -f $PACKAGES_REPOSITORY/$PACKAGE-$VERSION.tazpkg ]; then
			[ -z "$EXTRAVERSION" ] && EXTRAVERSION="_$KERNEL"
			if [ ! -f $PACKAGES_REPOSITORY/$PACKAGE-${VERSION}$EXTRAVERSION.tazpkg ]; then
				[ "$1" = "report" ] && echo "Missing : $PACKAGE ($VERSION)"
				echo "Missing : $PACKAGE ($VERSION)" >> $DB_DIR/report
				echo "$PACKAGE" >> $DB_DIR/cooklist
			fi
		else
			# Check if package is up-to-date.
			PKG_DATE=`date -u -r $PACKAGES_REPOSITORY/$PACKAGE-${VERSION}${EXTRAVERSION}.tazpkg '+%m%d%H%M%Y'`
			for file in `find $pkg -type f`
			do
				FILE_DATE=`date -u -r $file '+%m%d%H%M%Y'`
				[ "$2" = "--verbose" ] && echo " -> Checking: $file"
				if [ "$FILE_DATE" -gt "$PKG_DATE" ] && ! grep -q $PACKAGE $DB_DIR/cooklist; then
					[ "$1" = "report" ] && echo "Refresh : $PACKAGE ($VERSION)"
					echo "Refresh : $PACKAGE ($VERSION)" >> $DB_DIR/report
					echo "$PACKAGE" >> $DB_DIR/cooklist
				fi
			done
		fi
		# Now check if package is built and not already in the list.
		if [ ! -d $BUILD_WOK/$PACKAGE/taz ] && ! grep -q $PACKAGE $DB_DIR/cooklist; then
			[ "$1" = "report" ] && echo "Unbuilt : $PACKAGE ($VERSION)"
			echo "Unbuilt : $PACKAGE ($VERSION)" >> $DB_DIR/report
			echo "$PACKAGE" >> $DB_DIR/cooklist
		fi
		# Rebuild unbuilt packages list with link to log file. This list
		# is also generated by cook_inslall to have real time stats.
		if [ ! -d $BUILD_WOK/$PACKAGE/taz ]; then
			echo "<a href=\"log.php?package=$(escape $PACKAGE)\">$PACKAGE</a>" \
				>> $DB_DIR/unbuilt
		fi
	done
	packages_summary
}

# Create a new cooklist and summary (dont modify report) so 'tazbb cook-commit'
# can cook last changes.
check_commit()
{
	echo "(checking commit)" > $DB_DIR/running
	cd $HG_WOK
	# Clean up last results.
	rm -f $DB_DIR/cooklist && touch $DB_DIR/cooklist
	# Get the name of modified packages by the revision range. +1 last
	# commit was build by the previous build.
	LAST_REV=$(($LAST_REV+1))
	echo -e "Will cook from revision $LAST_REV to $NEW_REV\n"
	for file in `hg log --rev=$LAST_REV:$NEW_REV --template '{files}\n'`
	do
		pkg=`echo $file | cut -d "/" -f 1`
		if ! grep -q ^$pkg$ $DB_DIR/cooklist; then
			. $pkg/receipt
			echo "Commit  : $PACKAGE ($VERSION)" >> $DB_DIR/report
			echo "$PACKAGE" >> $DB_DIR/cooklist
		fi
	done
	packages_summary
}

# Cook one package
cook_package()
{
	EXTRAVERSION=""
	DEPENDS=""
	BUILD_DEPENDS=""
	SOURCE=""
	WANTED=""
	echo "(cooking <a href=\"log.php?package=$(escape $pkg)\">$pkg</a>)" > $DB_DIR/running
	tazwok clean $pkg
	script -c "echo 'install' | tazwok cook $pkg" $LOG_DIR/$pkg.log
	# Install new package (important for new shared libs). Note
	# that tests are done separatly with 'test_packages' and should
	# be done by tazwok.
	if [ -f $BUILD_WOK/$pkg/taz/*/receipt ]; then
		. $BUILD_WOK/$pkg/taz/*/receipt
		echo "(installing $PACKAGE-${VERSION}$EXTRAVERSION.tazpkg)" \
			> $DB_DIR/running
		yes | tazpkg install \
			$PACKAGES_REPOSITORY/$PACKAGE-${VERSION}$EXTRAVERSION.tazpkg \
			--forced
		return 0
	fi
	return 1
}

# Sort list according WANTED and BUILD_DEPENDS
sort_cook_list()
{
	sort | while read pkg; do
		echo -n "$pkg"
		WANTED=""
		BUILD_DEPENDS=""
		. $BUILD_WOK/$pkg/receipt
		MISSING=""
		for i in $WANTED $BUILD_DEPENDS ; do
			if [ ! -f $BUILD_WOK/$i/taz/*/receipt ]; then
				case " $MISSING " in
				*\ $i\ *);;
				*) echo -n " $i";;
				esac
				MISSING="$MISSING $i"
			fi
		done
		echo ""
	done | awk '
function show(name)
{
	print name;
	got[name]++;
	if (revdepcnt[name] > 0)
		for (i = split(revdep[name], pkg, " "); i > 0; i--)
			if (--depcnt[pkg[i]] == 0) show(pkg[i]);
}

{
	if ($2 == "") show($1);
	else {
		depcnt[$1] = NF - 1;
		unres = unres " " $1;
		for (i = 2; i <= NF; i++) {
			if (got[$i] > 0) continue;
			revdepcnt[$i]++;
			revdep[$i] = revdep[$i] " " $1;
		}
	}
}
END {
	for (i = split(unres, pkg, " "); i > 0; i--)
		if (depcnt[pkg[i]] > 0) print pkg[i];
}
'
}

# Here we cook all packages found in the cooklist.
cook_install()
{
	echo "" > $DB_DIR/unbuilt
	for pkg in `cat $DB_DIR/cooklist | sort_cook_list`
	do
		if ! cook_package $pkg; then
			# Link to build log.
			echo "<a href=\"log.php?package=$(escape $pkg)\">$pkg</a>" >> \
				$DB_DIR/unbuilt
		fi
		# Remove package from the cooklist and empty lines for HTML <pre>.
		sed -i /"^$pkg$"/d $DB_DIR/cooklist
		sed -i '/^$/d' $DB_DIR/cooklist
		packages_summary_update
	done
}

# Remove old packages in the build wok and clean pkgs repository. The
# Hg wok is copied into the build wok so packages removed by hg must be
# removed. To remove old packages in the repository we look into the
# build wok and dont remove unbuilt packages. Clean-up will also remove
# all corrupted packages.
clean_up()
{
	touch $DB_DIR/removed
	echo -e "\nCleaning the build wok, old and corrupted packages...\n"
	echo "(cleaning)" > $DB_DIR/running
	for pkg in `ls $BUILD_WOK`
	do
		if [ ! -d $HG_WOK/$pkg ]; then
			case $2 in
				--dry-run)
					echo "Removing directory : $pkg" ;;
				--verbose)
					echo "Removing directory : $pkg"
					rm -rf $BUILD_WOK/$pkg ;;
				*)
					rm -rf $BUILD_WOK/$pkg ;;
			esac
		fi
	done
	# Build a packages list with EXTRAVERSION so we can grep into it.
	rm -f $DB_DIR/packaged && touch $DB_DIR/packaged
	for receipt in $BUILD_WOK/*/taz/*/receipt
	do
		EXTRAVERSION=""
		. $receipt
		echo "$PACKAGE-${VERSION}$EXTRAVERSION.tazpkg" >> $DB_DIR/packaged
	done
	for pkg in `cd $PACKAGES_REPOSITORY && ls *.tazpkg`
	do
		if ! grep -q "^$pkg$" $DB_DIR/packaged; then
			case $2 in
				--dry-run)
					echo "Removing package : $pkg" ;;
				--verbose)
					echo "Removing package : $pkg"
					echo "$pkg" >> $DB_DIR/removed
					rm -f $PACKAGES_REPOSITORY/$pkg ;;
				*)
					echo "$pkg" >> $DB_DIR/removed
					rm -f $PACKAGES_REPOSITORY/$pkg ;;
			esac
		fi
	done
	# Remove all corrupted packages
	for pkg in `cat $DB_DIR/corrupted | awk '{ print $3 }'`
	do
		case $2 in
			--dry-run)
				echo "Removing corrupted: $pkg" ;;
			--verbose)
				echo "Removing corrupted: $pkg"
				echo "$pkg" >> $DB_DIR/removed
				rm -rf $PACKAGES_REPOSITORY/$pkg ;;
			*)
				echo "$pkg" >> $DB_DIR/removed
				rm -rf $PACKAGES_REPOSITORY/$pkg ;;
		esac
	done
	echo ""
	# Keep the 20 last removed packages list.
	cat $DB_DIR/removed | tail -n 20 > /tmp/removed.tail
	mv -f /tmp/removed.tail $DB_DIR/removed
}

blocked_urls()
{
	rm -f $DB_DIR/blocked.urls
	for pkg in `cat $DB_DIR/blocked`
	do
		if [ -f $LOG_DIR/$pkg.log ]; then
			echo "<a href=\"log.php?package=$(escape $pkg)\">$pkg</a>" >> \
				$DB_DIR/blocked.urls
		else
			echo "$pkg" >> $DB_DIR/blocked.urls
		fi
	done
}

# 4k, not a meta or a get-* package and no files = buggy package
test_packages()
{
	echo -e "\nTesting all packages in: $PACKAGES_REPOSITORY"
	echo "================================================================================"
	echo "(testing packages)" > $DB_DIR/running
	rm -f $DB_DIR/corrupted && touch $DB_DIR/corrupted
	for pkg in $PACKAGES_REPOSITORY/*.tazpkg
	do
		tmp=/tmp/bb-test.$$
		CATEGORY=""
		if du $pkg | grep -qw '^4' && ! echo `basename $pkg` | grep -q '^get-'; then
			mkdir -p $tmp && cd $tmp
			cpio -i receipt 2>/dev/null < $pkg
			. ./receipt
			if [ "$CATEGORY" != "meta" ]; then
				[ "$2" = "--verbose" ] && echo "Testing: $PACKAGE"
				cpio -i fs.cpio.gz 2>/dev/null < $pkg
				if [ ! -f fs.cpio.gz ]; then
					echo "Missing filesystem    `basename $pkg`"
					if [ -f $LOG_DIR/$PACKAGE.log ];then
						echo "Missing filesystem    `basename $pkg` <a href=\"log.php?package=$(escape $PACKAGE)\">Log</a>" \
							>> $DB_DIR/corrupted
					else
						echo "Missing filesystem    `basename $pkg`" \
							>> $DB_DIR/corrupted
					fi
				else
					zcat fs.cpio.gz | cpio -id 2>/dev/null
					files=`find fs -type f -o -type l`
					if [ -z "$files" ]; then
						echo "Empty filesystem      `basename $pkg`"
						if [ -f $LOG_DIR/$PACKAGE.log ]; then
							echo "Empty filesystem      `basename $pkg` <a href=\"log.php?package=$(escape $PACKAGE)\">Log</a>" \
								>> $DB_DIR/corrupted
						else
							echo "Empty filesystem      `basename $pkg`" \
							>> $DB_DIR/corrupted
						fi
					fi
				fi
			fi
			cd .. && rm -rf $tmp
		fi
	done
	packages_summary_update
	echo ""
}

# Generate flavor list
gen_flavor_list()
{
	cd $PACKAGES_REPOSITORY
	noheader=""
	for i in *.flavor; do
		tazlito show-flavor $i --brief $noheader
		noheader="--noheader"
	done > flavors.list
	cd - > /dev/null
}

case "$1" in
	list-pkgs)
		# List last cooked packages.
		list_packages ;;
	report)
		# Run in report mode. If an update is done we must cook-all to
		# rebuild all updated packages.
		[ "$2" == "--update" ] && update_wok $@ || echo ""
		check_wok $@
		check_flavors $@
		test_packages $@
		show_report ;;
	cook)
		# Cook, install and log a single package build.
		if [ -z $2 ]; then
			echo "Please specify a package on the command line."
			rm -f $LOCK_FILE && exit 0
		fi
		pkg=$2
		echo "Starting to cook and install: $pkg"
		if ! cook_package $pkg; then
			echo "Unable to install: $pkg"
		fi ;;
	cook-all)
		# Update wok, gen report (with cooklist), cook all packages, test,
		# clean, gen new report and lists.
		update_wok $@
		check_wok $@
		cook_install
		test_packages $@
		clean_up $@
		check_wok $@
		echo "(generating lists)" > $DB_DIR/running
		tazwok gen-list --text
		check_flavors $@
		pack_flavors
		gen_flavor_list
		echo "" ;;
	cook-commit)
		# Cook all packages affected by the last commits in the wok.
		# Clean up is done only by cook-all to avoid rebuild of corrupted
		# packages on each commit.
		update_wok $@
		check_commit
		cook_install
		test_packages $@
		check_wok $@
		echo "(generating lists)" > $DB_DIR/running
		tazwok gen-list --text
		check_flavors $@
		pack_flavors
		gen_flavor_list
		echo "" ;;
	block)
		# Add a pkg name to the list of blocked packages.
		echo ""
		if grep -qs "^$2$" $DB_DIR/blocked; then
			echo -e "$2 is already in the blocked packages list."
		else
			echo -n "Adding $2 to     : $DB_DIR/blocked... "
			echo "$2" >> $DB_DIR/blocked && echo "Done"
			if grep -q "^$2$" $DB_DIR/cooklist; then
				echo -n "Removing $2 from : $DB_DIR/cooklist... "
				sed -i /"^$2$"/d $DB_DIR/cooklist && echo "Done"
				packages_summary_update
			fi
		fi
		blocked_urls
		echo "" ;;
	unblock)
		# Remove a pkg name from the list of blocked packages.
		echo ""
		if grep -qs "^$2$" $DB_DIR/blocked; then
			echo -n "Removing $2 from : $DB_DIR/blocked... "
			sed -i /"^$2$"/d $DB_DIR/blocked
			sed -i '/^$/d' $DB_DIR/blocked && echo "Done"
			echo -n "Adding $2 to     : $DB_DIR/cooklist... "
			echo "$2" >> $DB_DIR/cooklist && echo "Done"
			packages_summary_update
		else
			echo -e "$2 is not in the blocked packages list."
		fi
		blocked_urls
		echo "" ;;
	test-pkgs)
		# Start a test suite on all builded packages.
		test_packages $@ ;;
	test-suite)
		# Start a test suite on all builded package and the wok using
		# the great 'tazwok check'.
		#
		# test_packages > $LOG_DIR/test-suite.log
		# tazwok check >> $LOG_DIR/test-suite.log
		#
		test_packages $@
		script -c "tazwok check" $LOG_DIR/test-suite.log ;;
	mail)
		# Tazbbmail Pythom script wrapper.
		PACKAGE=$2
		tazbbmail $PACKAGE ;;
	clean-up)
		# Remove old packages and generate new packages lists.
		update_wok $@
		clean_up $@
		packages_summary_update
		[ "$2" != "--dry-run" ] && tazwok gen-list --text ;;
	clean-log)
		logs=`ls $LOG_DIR | wc -l`
		echo -n "Cleaning: $LOG_DIR... "
		rm -rf $LOG_DIR/*
		echo "$logs log removed" ;;
	*)
		usage ;;
esac

echo "" > $DB_DIR/running
rm -f $LOCK_FILE

exit 0
