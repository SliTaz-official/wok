--- busybox-1.12.0/modutils/depmod.c
+++ busybox-1.12.0/modutils/depmod.c
@@ -53,27 +53,14 @@ static int FAST_FUNC fileAction(const ch
 	size_t len = sb->st_size;
 	void *the_module;
 	char *ptr;
-	int fd;
 	char *depends, *deps;
 	dep_lst_t *this;
+	extern void *xalloc_load_module(const char filename[], size_t *len);
 
 	if (strrstr(fname, ".ko") == NULL) /* not a module */
 		goto skip;
 
-/*XXX: FIXME: does not handle compressed modules!
- * There should be a function that looks at the extension and sets up
- * open_transformer for us.
- */
-	fd = xopen(fname, O_RDONLY);
-	the_module = mmap(NULL, len, PROT_READ, MAP_SHARED
-#if defined MAP_POPULATE
-						|MAP_POPULATE
-#endif
-						, fd, 0);
-	close(fd);
-	if (the_module == MAP_FAILED)
-		bb_perror_msg_and_die("mmap");
-
+	the_module = xalloc_load_module(fname, &len);
 	this = xzalloc(sizeof(dep_lst_t));
 	this->name = xstrdup(fname);
 	this->next = G.lst;
@@ -104,7 +91,7 @@ static int FAST_FUNC fileAction(const ch
 			pos = (ptr - (char*)the_module);
 		} while (1);
 	}
-	munmap(the_module, sb->st_size);
+	free(the_module);
  skip:
 	return TRUE;
 }

--- busybox-1.12.0/modutils/insmod.c
+++ busybox-1.12.0/modutils/insmod.c
@@ -59,6 +59,7 @@
  */
 
 #include "libbb.h"
+#include "unarchive.h"
 #include <libgen.h>
 #include <sys/utsname.h>
 
@@ -4212,6 +4213,45 @@ static const char *moderror(int err)
 	}
 }
 
+void *xalloc_load_module(const char filename[], size_t *len);
+void *xalloc_load_module(const char filename[], size_t *len)
+{
+	int fd, max;
+	unsigned char head[16];
+	void *map;
+	size_t l;
+
+	max = 8 * 1024;
+	fd = open(filename, O_RDONLY);
+	if (fd < 0) return NULL;
+	xread(fd,head,sizeof(head));
+	lseek(fd,0L,SEEK_SET);
+	if (head[0] == 0x1f && head[1] == 0x8b) { /* gzip */
+		open_transformer(fd, unpack_gz_stream, "gunzip");
+	}
+	else if (head[0] == 'B' && head[1] == 'Z' && 
+			 head[2] == 'h' && isdigit(head[3])) { /* bzip2 */
+		open_transformer(fd, unpack_bz2_stream, "bunzip2");
+	}
+	else if (head[1] != 'E' || head[2] != 'L' || head[3] != 'F') {
+		open_transformer(fd, unpack_lzma_stream, "unlzma");
+		if (* (unsigned *) (head + 9) == 0)
+			max = 1 + head[5] + (head[6]<<8) 
+				+ (head[7]<<16) + (head[8]<<24);
+	}
+	l = 0;
+	map = xmalloc(max);
+	while (1) {
+		l += full_read(fd, l + (char *) map, max - l);
+		if (l != max) break;
+		max <<= 1;
+		map = xrealloc(map, max);
+	}
+	if (len)
+		*len = l;
+	return xrealloc(map, l);
+}
+
 #if !ENABLE_FEATURE_2_4_MODULES
 int insmod_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int insmod_main(int argc UNUSED_PARAM, char **argv)
@@ -4264,8 +4304,7 @@ static int insmod_ng_main(int argc UNUSE
 		xread(fd, map, len);
 	}
 #else
-	len = MAXINT(ssize_t);
-	map = xmalloc_open_read_close(filename, &len);
+	map = xalloc_load_module(filename, &len);
 #endif
 
 	if (init_module(map, len, options) != 0)

--- busybox-1.12.0/modutils/modprobe.c
+++ busybox-1.12.0/modutils/modprobe.c
@@ -396,6 +396,29 @@ static int include_conf_file2(struct inc
 	return include_conf_file(conf, oldname);
 }
 
+static int ext_size(char *end USE_FEATURE_2_6_MODULES(, int k_version))
+{
+	int ext;
+	char *next;
+
+	ext = 0;
+	if (end[-2] == '.' && end[-1] == 'g' && end[0] == 'z')
+		ext = 3;
+	if (end[-3] == '.' && end[-2] == 'b' && end[-1] == 'z' && end[0] == '2')
+		ext = 4;
+	next = end - ext;
+#if ENABLE_FEATURE_2_6_MODULES
+	if (ENABLE_FEATURE_2_6_MODULES
+			&& (k_version > 4) && (next[-2] == '.')
+			&& (next[-1] == 'k') && (next[0] == 'o'))
+		ext += 3;
+	else 
+#endif
+	if ((next[-1] == '.') && (next[0] == 'o'))
+		ext += 2;
+	return ext;
+}
+
 /*
  * This function builds a list of dependency rules from /lib/modules/`uname -r`/modules.dep.
  * It then fills every modules and aliases with their default options, found by parsing
@@ -464,12 +487,7 @@ static struct dep_t *build_dep(void)
 				if (!modpath)
 					modpath = line_buffer; /* module with no path */
 				/* find the end of the module name in the file name */
-				if (ENABLE_FEATURE_2_6_MODULES &&
-				    (k_version > 4) && (col[-3] == '.') &&
-				    (col[-2] == 'k') && (col[-1] == 'o'))
-					dot = col - 3;
-				else if ((col[-2] == '.') && (col[-1] == 'o'))
-					dot = col - 2;
+				dot = col - ext_size(col - 1 USE_FEATURE_2_6_MODULES(, k_version));
 
 				mod = xstrndup(mods, dot - mods);
 
@@ -522,12 +540,7 @@ static struct dep_t *build_dep(void)
 					deps = skip_whitespace(deps);
 
 				/* find the end of the module name in the file name */
-				if (ENABLE_FEATURE_2_6_MODULES
-				 && (k_version > 4) && (next[-2] == '.')
-				 && (next[-1] == 'k') && (next[0] == 'o'))
-					ext = 3;
-				else if ((next[-1] == '.') && (next[0] == 'o'))
-					ext = 2;
+				ext = ext_size(next USE_FEATURE_2_6_MODULES(, k_version));
 
 				/* Cope with blank lines */
 				if ((next - deps - ext + 1) <= 0)
