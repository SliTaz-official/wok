--- busybox-1.12.0/modutils/depmod.c
+++ busybox-1.12.0/modutils/depmod.c
@@ -53,27 +53,14 @@ static int FAST_FUNC fileAction(const ch
 	size_t len = sb->st_size;
 	void *the_module;
 	char *ptr;
-	int fd;
 	char *depends, *deps;
 	dep_lst_t *this;
+	extern void *xalloc_load_module(const char filename[], size_t *len);
 
 	if (strrstr(fname, ".ko") == NULL) /* not a module */
 		goto skip;
 
-/*XXX: FIXME: does not handle compressed modules!
- * There should be a function that looks at the extension and sets up
- * open_transformer for us.
- */
-	fd = xopen(fname, O_RDONLY);
-	the_module = mmap(NULL, len, PROT_READ, MAP_SHARED
-#if defined MAP_POPULATE
-						|MAP_POPULATE
-#endif
-						, fd, 0);
-	close(fd);
-	if (the_module == MAP_FAILED)
-		bb_perror_msg_and_die("mmap");
-
+	the_module = xalloc_load_module(fname, &len);
 	this = xzalloc(sizeof(dep_lst_t));
 	this->name = xstrdup(fname);
 	this->next = G.lst;
@@ -104,7 +91,7 @@ static int FAST_FUNC fileAction(const ch
 			pos = (ptr - (char*)the_module);
 		} while (1);
 	}
-	munmap(the_module, sb->st_size);
+	free(the_module);
  skip:
 	return TRUE;
 }

--- busybox-1.12.0/modutils/insmod.c
+++ busybox-1.12.0/modutils/insmod.c
@@ -59,6 +59,7 @@
  */
 
 #include "libbb.h"
+#include "unarchive.h"
 #include <libgen.h>
 #include <sys/utsname.h>
 
@@ -4212,6 +4213,60 @@ static const char *moderror(int err)
 	}
 }
 
+void *xalloc_load_module(const char filename[], size_t *len);
+void *xalloc_load_module(const char filename[], size_t *len)
+{
+	int fd, max;
+	unsigned char head[16];
+	void *map;
+	size_t l;
+
+	max = 8 * 1024;
+	fd = open(filename, O_RDONLY);
+	if (fd < 0) return NULL;
+	xread(fd,head,sizeof(head));
+	lseek(fd,0L,SEEK_SET);
+#if ENABLE_FEATURE_SEAMLESS_GZ
+	if (head[0] == 0x1f && head[1] == 0x8b) { /* gzip */
+#if BB_MMU
+		xread(fd,head,2); // bb wierdness...
+#endif
+		open_transformer(fd, unpack_gz_stream, "gunzip");
+	}
+#endif
+#if ENABLE_FEATURE_SEAMLESS_BZ2
+#if ENABLE_FEATURE_SEAMLESS_GZ
+	else
+#endif
+	if (head[0] == 'B' && head[1] == 'Z' && 
+			 head[2] == 'h' && isdigit(head[3])) { /* bzip2 */
+		open_transformer(fd, unpack_bz2_stream, "bunzip2");
+	}
+#endif
+#if ENABLE_FEATURE_SEAMLESS_LZMA
+#if ENABLE_FEATURE_SEAMLESS_GZ || ENABLE_FEATURE_SEAMLESS_BZ2
+	else
+#endif
+	if (head[1] != 'E' || head[2] != 'L' || head[3] != 'F') {
+		open_transformer(fd, unpack_lzma_stream, "unlzma");
+		if (* (unsigned *) (head + 9) == 0)
+			max = 1 + head[5] + (head[6]<<8) 
+				+ (head[7]<<16) + (head[8]<<24);
+	}
+#endif
+	l = 0;
+	map = xmalloc(max);
+	while (1) {
+		l += full_read(fd, l + (char *) map, max - l);
+		if (l != max) break;
+		max <<= 1;
+		map = xrealloc(map, max);
+	}
+	if (len)
+		*len = l;
+	return xrealloc(map, l);
+}
+
 #if !ENABLE_FEATURE_2_4_MODULES
 int insmod_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int insmod_main(int argc UNUSED_PARAM, char **argv)
@@ -4276,8 +4319,7 @@ static int insmod_ng_main(int argc UNUSE
 		xread(fd, map, len);
 	}
 #else
-	len = MAXINT(ssize_t);
-	map = xmalloc_open_read_close(filename, &len);
+	map = xalloc_load_module(filename, &len);
 #endif
 
 	if (init_module(map, len, options) != 0)

--- busybox-1.12.0/modutils/modprobe.c
+++ busybox-1.12.0/modutils/modprobe.c
@@ -396,6 +396,29 @@ static int include_conf_file2(struct inc
 	return include_conf_file(conf, oldname);
 }
 
+static int ext_size(char *end USE_FEATURE_2_6_MODULES(, int k_version))
+{
+	int ext;
+	char *next;
+
+	ext = 0;
+	if (end[-2] == '.' && end[-1] == 'g' && end[0] == 'z')
+		ext = 3;
+	if (end[-3] == '.' && end[-2] == 'b' && end[-1] == 'z' && end[0] == '2')
+		ext = 4;
+	next = end - ext;
+#if ENABLE_FEATURE_2_6_MODULES
+	if (ENABLE_FEATURE_2_6_MODULES
+			&& (k_version > 4) && (next[-2] == '.')
+			&& (next[-1] == 'k') && (next[0] == 'o'))
+		ext += 3;
+	else 
+#endif
+	if ((next[-1] == '.') && (next[0] == 'o'))
+		ext += 2;
+	return ext;
+}
+
 /*
  * This function builds a list of dependency rules from /lib/modules/`uname -r`/modules.dep.
  * It then fills every modules and aliases with their default options, found by parsing
@@ -464,12 +487,7 @@ static struct dep_t *build_dep(void)
 				if (!modpath)
 					modpath = line_buffer; /* module with no path */
 				/* find the end of the module name in the file name */
-				if (ENABLE_FEATURE_2_6_MODULES &&
-				    (k_version > 4) && (col[-3] == '.') &&
-				    (col[-2] == 'k') && (col[-1] == 'o'))
-					dot = col - 3;
-				else if ((col[-2] == '.') && (col[-1] == 'o'))
-					dot = col - 2;
+				dot = col - ext_size(col - 1 USE_FEATURE_2_6_MODULES(, k_version));
 
 				mod = xstrndup(mods, dot - mods);
 
@@ -522,12 +540,7 @@ static struct dep_t *build_dep(void)
 					deps = skip_whitespace(deps);
 
 				/* find the end of the module name in the file name */
-				if (ENABLE_FEATURE_2_6_MODULES
-				 && (k_version > 4) && (next[-2] == '.')
-				 && (next[-1] == 'k') && (next[0] == 'o'))
-					ext = 3;
-				else if ((next[-1] == '.') && (next[0] == 'o'))
-					ext = 2;
+				ext = ext_size(next USE_FEATURE_2_6_MODULES(, k_version));
 
 				/* Cope with blank lines */
 				if ((next - deps - ext + 1) <= 0)

--- busybox-1.12.0/modutils/depmod.c
+++ busybox-1.12.0/modutils/depmod.c
@@ -109,11 +109,15 @@
 		ARG_b = (1<<2), /* not /lib/modules/$(uname -r)/ but this base-dir */
 		ARG_e = (1<<3), /* with -F, print unresolved symbols */
 		ARG_F = (1<<4), /* System.map that contains the symbols */
-		ARG_n = (1<<5)  /* dry-run, print to stdout only */
+		ARG_n = (1<<5), /* dry-run, print to stdout only */
+		ARG_u = (1<<6), /* unresolved-error: ignored */
+		ARG_q = (1<<7), /* quiet: ignored */
+		ARG_r = (1<<8), /* root: ignored */
+		ARG_C = (1<<9)  /* config: ignored */
 	};
 	INIT_G();
 
-	getopt32(argv, "aAb:eF:n", &moddir_base, &system_map);
+	getopt32(argv, "aAb:eF:nuqrC", &moddir_base, &system_map);
 	argv += optind;
 
 	/* If a version is provided, then that kernel versionâ€™s module directory

--- busybox-1.12.0/modutils/depmod.c
+++ busybox-1.12.0/modutils/depmod.c
@@ -141,6 +141,11 @@
 
 	if (!(option_mask32 & ARG_n)) { /* --dry-run */
 		chp = concat_path_file(moddir, CONFIG_DEFAULT_DEPMOD_FILE);
+		if (option_mask32 & ARG_b) {
+			char *s = concat_path_file(moddir_base, chp);
+			free(chp);
+			chp = s;
+		}
 		filedes = xfopen_for_write(chp);
 		if (ENABLE_FEATURE_CLEAN_UP)
 			free(chp);
