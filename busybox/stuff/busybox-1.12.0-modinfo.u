--- busybox-1.12.0/include/applets.h
+++ busybox-1.12.0/include/applets.h
@@ -251,6 +251,7 @@ USE_MKFS_MINIX(APPLET_ODDNAME(mkfs.minix
 USE_MKNOD(APPLET(mknod, _BB_DIR_BIN, _BB_SUID_NEVER))
 USE_MKSWAP(APPLET(mkswap, _BB_DIR_SBIN, _BB_SUID_NEVER))
 USE_MKTEMP(APPLET(mktemp, _BB_DIR_BIN, _BB_SUID_NEVER))
+USE_MODINFO(APPLET(modinfo, _BB_DIR_SBIN, _BB_SUID_NEVER))
 USE_MODPROBE(APPLET(modprobe, _BB_DIR_SBIN, _BB_SUID_NEVER))
 USE_MODPROBE_SMALL(APPLET(modprobe, _BB_DIR_SBIN, _BB_SUID_NEVER))
 USE_MORE(APPLET(more, _BB_DIR_BIN, _BB_SUID_NEVER))

--- busybox-1.12.0/include/usage.h
+++ busybox-1.12.0/include/usage.h
@@ -2629,6 +2629,20 @@
        "   which are the default for alias 'tulip2' overridden by the options 'irq=2 io=0x210'\n\n" \
        "   from the command line\n"
 
+#define modinfo_trivial_usage \
+       "[-adlp0] [-F keyword] MODULE"
+#define modinfo_full_usage "\n\n" \
+       "Options:" \
+     "\n	-a		Shortcut for '-F author'" \
+     "\n	-d		Shortcut for '-F description'" \
+     "\n	-l		Shortcut for '-F license'" \
+     "\n	-p		Shortcut for '-F parm'" \
+     "\n	-F keyword	Keyword to look for" \
+     "\n	-0		Use \\0 string separator. Not \\n" \
+
+#define modinfo_example_usage \
+       "$ modinfo -F vermagic loop\n"
+       
 #define more_trivial_usage \
        "[FILE...]"
 #define more_full_usage "\n\n" \

--- busybox-1.12.0/modutils/Config.in
+++ busybox-1.12.0/modutils/Config.in
@@ -213,6 +213,12 @@ config FEATURE_MODPROBE_BLACKLIST
 	  hardware autodetection scripts to load modules like evdev, frame
 	  buffer drivers etc.
 
+config MODINFO
+	bool "modinfo"
+	default n
+	help
+	  Show information about a Linux Kernel module
+
 comment "Options common to multiple modutils"
 	depends on INSMOD || RMMOD || MODPROBE || LSMOD || DEPMOD
 

--- busybox-1.12.0/modutils/Kbuild
+++ busybox-1.12.0/modutils/Kbuild
@@ -11,3 +11,4 @@ lib-$(CONFIG_LSMOD)             += lsmod
 lib-$(CONFIG_MODPROBE)          += modprobe.o
 lib-$(CONFIG_MODPROBE_SMALL)    += modprobe-small.o
 lib-$(CONFIG_RMMOD)             += rmmod.o
+lib-$(CONFIG_MODINFO)           += modinfo.o

--- busybox-1.12.0/modutils/modinfo.c
+++ busybox-1.12.0/modutils/modinfo.c
@@ -0,0 +1,104 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * modinfo - retrieve module info
+ * Copyright (c) 2008 Pascal Bellard
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
+ */
+
+#undef _GNU_SOURCE
+#define _GNU_SOURCE
+#include <libbb.h>
+#include <fnmatch.h>
+
+#define ALL_TAGS	0x3F
+
+enum {
+	ARG_F = (1<<6), /* field name */
+	ARG_0 = (1<<7)  /* \0 as separator */
+};
+
+struct modinfo_env {
+	char **argv;
+	const char **literals;
+	char *field;
+	int tags;
+};
+
+static int display(char *data, const char *pattern, int flag)
+{
+	if (flag) {
+		int n = printf("%s:",pattern);
+		while (n++ < 16) bb_putchar(' ');
+	}
+	return printf("%s%c",data, (option_mask32 & ARG_0) ? '\0' : '\n');
+}
+
+static void modinfo(char *name, char *path, void *env)
+{
+	size_t len;
+	int i, j, length;
+	char *ptr, *the_module;
+	char **argv = ((struct modinfo_env *) env)->argv;
+	const char **literals = ((struct modinfo_env *) env)->literals;
+	const char *field = ((struct modinfo_env *) env)->field;
+	int tags = ((struct modinfo_env *) env)->tags;
+	extern void *xalloc_load_module(const char filename[], size_t *len);
+
+	for (i = 0; argv[i]; i++) {
+		if (fnmatch(argv[i],name,0) == 0) {
+			if (tags & 1) { /* filename */
+				display(path,literals[0],1 != tags);
+			}
+			len = MAXINT(ssize_t);
+			the_module = xalloc_load_module(path, &len);
+			if (field) tags |= ALL_TAGS+1;
+			for (j = 1; (1<<j) & (ALL_TAGS+ALL_TAGS+1); j++)	{
+				const char *pattern = field;
+				if ((1<<j) & ALL_TAGS) pattern = literals[j];
+				if (!((1<<j) & tags)) continue;
+				length = strlen(pattern);
+				ptr = the_module;
+				do {
+					ptr = memchr(ptr, *pattern, len - (ptr - (char*)the_module));
+					if (ptr == NULL) /* no occurance left, done */
+						break;
+					if (!strncmp(ptr, pattern, length) && ptr[length] == '=') {
+						ptr += length + 1;
+						ptr += display(ptr,pattern,(1<<j) != tags);
+					}
+					++ptr;
+				} while (1);
+			}
+			free(the_module);
+		}
+	}
+}
+
+int modinfo_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int modinfo_main(int argc UNUSED_PARAM, char **argv)
+{
+	static const char *shortcuts[] = {
+		"filename",
+		"description",
+		"author",
+		"license",
+		"vermagic",
+		"parm",
+	};
+	struct modinfo_env env;
+	extern void mod_walk(void (*action)(char *name, char *path, void *env),
+						 void *data);
+
+	env.field = NULL;
+	env.literals = shortcuts;
+	getopt32(argv, "fdalvpF:0", &env.field);
+	env.argv = argv += optind;
+	env.tags = (option_mask32) ? option_mask32 & ALL_TAGS : ALL_TAGS;
+
+	if (!*env.argv)
+		bb_show_usage();
+
+	mod_walk(modinfo, &env);
+	return 0;
+}
