--- busybox-1.7.3/include/applets.h
+++ busybox-1.7.3/include/applets.h
@@ -284,6 +284,7 @@
 USE_RUNSV(APPLET(runsv, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
 USE_RUNSVDIR(APPLET(runsvdir, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
 USE_RX(APPLET(rx, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
+USE_SCRIPT(APPLET(script, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
 USE_SED(APPLET(sed, _BB_DIR_BIN, _BB_SUID_NEVER))
 USE_SELINUXENABLED(APPLET(selinuxenabled, _BB_DIR_USR_SBIN, _BB_SUID_NEVER))
 USE_SEQ(APPLET_NOFORK(seq, seq, _BB_DIR_USR_BIN, _BB_SUID_NEVER, seq))

--- busybox-1.7.3/include/libbb.h
+++ busybox-1.7.3/include/libbb.h
@@ -225,6 +225,7 @@
 	int (*dirAction) (const char *fileName, struct stat* statbuf, void* userData, int depth),
 	void* userData, unsigned depth);
 extern int device_open(const char *device, int mode);
+extern int getpty(char *line, int size);
 extern int get_console_fd(void);
 extern char *find_block_device(const char *path);
 /* bb_copyfd_XX print read/write errors and return -1 if they occur */

--- busybox-1.7.3/libbb/Kbuild
+++ busybox-1.7.3/libbb/Kbuild
@@ -38,6 +38,7 @@
 lib-y += get_last_path_component.o
 lib-y += get_line_from_file.o
 lib-y += getopt32.o
+lib-y += getpty.o
 lib-y += herror_msg.o
 lib-y += herror_msg_and_die.o
 lib-y += human_readable.o

--- busybox-1.7.3/libbb/getpty.c
+++ busybox-1.7.3/libbb/getpty.c
@@ -0,0 +1,56 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Mini getpty implementation for busybox
+ * Bjorn Wesen, Axis Communications AB (bjornw@axis.com)
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
+ */
+
+#include "libbb.h"
+
+int getpty(char *line, int size)
+{
+	int p;
+#if ENABLE_FEATURE_DEVPTS
+	p = open("/dev/ptmx", O_RDWR);
+	if (p > 0) {
+		const char *name;
+		grantpt(p);
+		unlockpt(p);
+		name = ptsname(p);
+		if (!name) {
+			bb_perror_msg("ptsname error (is /dev/pts mounted?)");
+			return -1;
+		}
+		safe_strncpy(line, name, size);
+		return p;
+	}
+#else
+	struct stat stb;
+	int i;
+	int j;
+
+	strcpy(line, "/dev/ptyXX");
+
+	for (i = 0; i < 16; i++) {
+		line[8] = "pqrstuvwxyzabcde"[i];
+		line[9] = '0';
+		if (stat(line, &stb) < 0) {
+			continue;
+		}
+		for (j = 0; j < 16; j++) {
+			line[9] = j < 10 ? j + '0' : j - 10 + 'a';
+			if (DEBUG)
+				fprintf(stderr, "Trying to open device: %s\n", line);
+			p = open(line, O_RDWR | O_NOCTTY);
+			if (p >= 0) {
+				line[5] = 't';
+				return p;
+			}
+		}
+	}
+#endif /* FEATURE_DEVPTS */
+	return -1;
+}
+
+

--- busybox-1.7.3/miscutils/Config.in
+++ busybox-1.7.3/miscutils/Config.in
@@ -329,6 +329,12 @@
 	help
 	  Receive files using the Xmodem protocol.
 
+config SCRIPT
+	bool "script"
+	default n
+	help
+	  The script makes typescript of terminal session.
+
 config STRINGS
 	bool "strings"
 	default n

--- busybox-1.7.3/networking/telnetd.c
+++ busybox-1.7.3/networking/telnetd.c
@@ -162,54 +162,6 @@
 	return memmove(ptr - num_totty, ptr0, num_totty);
 }
 
-
-static int
-getpty(char *line, int size)
-{
-	int p;
-#if ENABLE_FEATURE_DEVPTS
-	p = open("/dev/ptmx", O_RDWR);
-	if (p > 0) {
-		const char *name;
-		grantpt(p);
-		unlockpt(p);
-		name = ptsname(p);
-		if (!name) {
-			bb_perror_msg("ptsname error (is /dev/pts mounted?)");
-			return -1;
-		}
-		safe_strncpy(line, name, size);
-		return p;
-	}
-#else
-	struct stat stb;
-	int i;
-	int j;
-
-	strcpy(line, "/dev/ptyXX");
-
-	for (i = 0; i < 16; i++) {
-		line[8] = "pqrstuvwxyzabcde"[i];
-		line[9] = '0';
-		if (stat(line, &stb) < 0) {
-			continue;
-		}
-		for (j = 0; j < 16; j++) {
-			line[9] = j < 10 ? j + '0' : j - 10 + 'a';
-			if (DEBUG)
-				fprintf(stderr, "Trying to open device: %s\n", line);
-			p = open(line, O_RDWR | O_NOCTTY);
-			if (p >= 0) {
-				line[5] = 't';
-				return p;
-			}
-		}
-	}
-#endif /* FEATURE_DEVPTS */
-	return -1;
-}
-
-
 static void
 send_iac(struct tsession *ts, unsigned char command, int option)
 {

--- busybox-1.7.3/util-linux/script.c
+++ busybox-1.7.3/util-linux/script.c
@@ -0,0 +1,157 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * script implementation for busybox
+ *
+ * pascal.bellard@ads-lu.com
+ *
+ * Based on code from util-linux v 2.12r
+ * Copyright (c) 1980
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Licensed under GPLv2 or later, see file License in this tarball for details.
+ */
+
+#include <getopt.h>
+#include "libbb.h"
+
+struct globals {
+	int	parent, qflg;
+	struct termios tt;
+	const char *fname;
+};
+#define G (*ptr_to_globals)
+#define parent    (G.parent )
+#define qflg      (G.qflg   )
+#define tt        (G.tt     )
+#define fname     (G.fname  )
+#define INIT_G() do { \
+	PTR_TO_GLOBALS = xzalloc(sizeof(G)); \
+	fname = "typescript"; \
+} while (0)
+
+static void done(void)
+{
+	if (parent) {
+		tcsetattr(0, TCSAFLUSH, &tt);
+		if (qflg == 0) printf("Script done, file is %s\n", fname);
+	}
+	exit(0);
+}
+
+static void finish(int sig)
+{
+	(void) sig;
+	done();
+}
+
+#if ENABLE_GETOPT_LONG
+static const char getopt_longopts[] ALIGN1 =
+	"append\0"  No_argument       "a"
+	"command\0" Required_argument "c"
+	"flush\0"   No_argument       "f"
+	"quiet\0"   No_argument       "q"
+	;
+#endif
+
+int script_main(int argc, char *argv[]);
+int script_main(int argc, char *argv[])
+{
+	int opt, child, pty;
+	int mode = O_CREAT|O_TRUNC|O_WRONLY;
+	struct termios rtt;
+	const char	*shell;
+	struct	winsize win;
+	char	line[32];
+	char *cflg = NULL, shell_arg[] = "-i";
+
+	INIT_G();
+#if ENABLE_GETOPT_LONG
+	applet_long_options = getopt_longopts;
+#endif
+	opt = getopt32(argv, "ac:fq", &cflg);
+	if (opt & 1) {
+		mode = O_CREAT|O_APPEND|O_WRONLY;
+	}
+	if (opt & 2) {
+		shell_arg[1] = 'c';
+	}
+#define fflg (opt & 4)
+	if (opt & 8) {
+		qflg++;
+	}
+	argc -= optind;
+	argv += optind;
+	if (argc > 0) {
+		if (--argc > 0) {
+			bb_show_usage();
+		}
+		fname = argv[0];
+	}
+	shell = getenv("SHELL");
+	if (shell == NULL) {
+		shell = _PATH_BSHELL;
+	}
+	pty = getpty(line,sizeof(line));
+	if (pty < 0) {
+		bb_perror_msg_and_die("Out of pty's");
+	}
+	tcgetattr(0, &tt);
+	ioctl(0, TIOCGWINSZ, (char *)&win);
+	if (qflg == 0) {
+		printf("Script started, file is %s\n", fname);
+	}
+
+	rtt = tt;
+	cfmakeraw(&rtt);
+	rtt.c_lflag &= ~ECHO;
+	tcsetattr(0, TCSAFLUSH, &rtt);
+
+	signal(SIGCHLD, finish); /* catch SIGTERM of children */
+	parent = fork(); /* use pid as flag meaning 'I am the parent process' */
+	if (parent < 0) {
+		bb_perror_msg_and_die("fork");
+	}
+	if (parent) { /* parent: link mainshell stdin to pty master input */
+		/* endless copy: stdin will not be closed */
+		bb_copyfd_eof(0, pty);
+		/* not reached, but maybe bb_copyfd_eof behaviour will change ? */
+		done();
+	}
+	else {
+		child = fork();
+		if (child < 0) {
+			bb_perror_msg_and_die("fork");
+		}
+		if (child) { 
+			/* child1: link pty master output to mainshell stdout and file */
+			int		count, fdscript;
+			char	buf[256];
+			close(0);
+			fdscript = xopen(fname, mode);
+			/* copy until pty is close, i.e. child2 exits */
+			while ((count = read(pty, buf, sizeof(buf))) > 0) {
+				write(1, buf, count);
+				write(fdscript, buf, count);
+				if (fflg) {
+					fsync(fdscript);
+				}
+			}
+			done();
+		}
+		else { /* child2: link subshell input, output, error to pty slave */
+			close(pty);					/* close master */
+			pty = xopen(line, O_RDWR);	/* open slave */
+			tcsetattr(pty, TCSAFLUSH, &tt);
+			ioctl(pty, TIOCSWINSZ, (char *)&win);
+			setsid();
+			ioctl(pty, TIOCSCTTY, 0);
+			xmove_fd(pty, 0);
+			xdup2(0, 1);
+			xdup2(0, 2);
+			execl(shell, strrchr(shell, '/') + 1, shell_arg, cflg, NULL);
+			bb_perror_msg_and_die(shell);
+		}
+	}
+	/* not reached */
+	return 0;
+}

--- busybox-1.7.3/util-linux/Kbuild
+++ busybox-1.7.3/util-linux/Kbuild
@@ -26,6 +26,7 @@
 lib-$(CONFIG_PIVOT_ROOT)	+=pivot_root.o
 lib-$(CONFIG_RDATE)		+=rdate.o
 lib-$(CONFIG_READPROFILE)	+=readprofile.o
+lib-$(CONFIG_SCRIPT)		+=script.o
 lib-$(CONFIG_SETARCH)		+=setarch.o
 lib-$(CONFIG_SWAPONOFF)		+=swaponoff.o
 lib-$(CONFIG_SWITCH_ROOT)	+=switch_root.o
patch bug...   
--- busybox-1.7.3/include/usage.h
+++ busybox-1.7.3/include/usage.h
@@ -2931,5 +2931,15 @@
 #define rx_example_usage \
        "$ rx /tmp/foo\n"
 
+#define script_trivial_usage \
+	"[-afq] [-c COMMAND] [file]"
+#define script_full_usage \
+       "Options:\n" \
+       "	-a		append the output to file or typescript\n" \
+       "	-c COMMAND	run the COMMAND rather than an interactive shell.\n" \
+       "	-f		flush output after each write\n" \
+       "	-q		quiet."
+       
+
 #define sed_trivial_usage \
        "[-efinr] pattern [files...]"
patch bug...   
