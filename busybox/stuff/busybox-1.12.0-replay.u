--- busybox-1.12.0/util-linux/script.c
+++ busybox-1.12.0/util-linux/script.c
@@ -36,6 +36,15 @@
 	const char *shell;
 	char shell_opt[] = "-i";
 	char *shell_arg = NULL;
+	enum {
+		OPT_a = (1 << 0),
+		OPT_c = (1 << 1),
+		OPT_f = (1 << 2),
+		OPT_q = (1 << 3),
+#if ENABLE_REPLAY
+		OPT_t = (1 << 4),
+#endif
+	};
 
 #if ENABLE_GETOPT_LONG
 	static const char getopt_longopts[] ALIGN1 =
@@ -43,25 +52,28 @@
 		"command\0" Required_argument "c"
 		"flush\0"   No_argument       "f"
 		"quiet\0"   No_argument       "q"
+# if ENABLE_REPLAY
+		"timing\0"  No_argument       "t"
+# endif
 		;
 
 	applet_long_options = getopt_longopts;
 #endif
 	opt_complementary = "?1"; /* max one arg */
-	opt = getopt32(argv, "ac:fq", &shell_arg);
+	opt = getopt32(argv, "ac:fq" USE_REPLAY("t") , &shell_arg);
 	//argc -= optind;
 	argv += optind;
 	if (argv[0]) {
 		fname = argv[0];
 	}
 	mode = O_CREAT|O_TRUNC|O_WRONLY;
-	if (opt & 1) {
+	if (opt & OPT_a) {
 		mode = O_CREAT|O_APPEND|O_WRONLY;
 	}
-	if (opt & 2) {
+	if (opt & OPT_c) {
 		shell_opt[1] = 'c';
 	}
-	if (!(opt & 8)) { /* not -q */
+	if (!(opt & OPT_q)) {
 		printf("Script started, file is %s\n", fname);
 	}
 	shell = getenv("SHELL");
@@ -97,6 +109,10 @@
 #define buf bb_common_bufsiz1
 		struct pollfd pfd[2];
 		int outfd, count, loop;
+#if ENABLE_REPLAY
+		struct timeval tv;
+		double oldtime=time(NULL), newtime;
+#endif
 
 		outfd = xopen(fname, mode);
 		pfd[0].fd = pty;
@@ -118,15 +134,27 @@
 			}
 			if (pfd[0].revents) {
 				errno = 0;
+#if ENABLE_REPLAY
+				if (opt & OPT_t) {
+					gettimeofday(&tv, NULL);
+				}
+#endif
 				count = safe_read(pty, buf, sizeof(buf));
 				if (count <= 0 && errno != EAGAIN) {
 					/* err/eof from pty: exit */
 					goto restore;
 				}
 				if (count > 0) {
+#if ENABLE_REPLAY
+					if (opt & OPT_t) {
+						newtime = tv.tv_sec + (double) tv.tv_usec / 1000000;
+						fprintf(stderr, "%f %i\n", newtime - oldtime, count);
+						oldtime = newtime;
+					}
+#endif
 					full_write(STDOUT_FILENO, buf, count);
 					full_write(outfd, buf, count);
-					if (opt & 4) { /* -f */
+					if (opt & OPT_f) {
 						fsync(outfd);
 					}
 				}
@@ -158,7 +186,7 @@
  restore:
 		if (attr_ok == 0)
 			tcsetattr(0, TCSAFLUSH, &tt);
-		if (!(opt & 8)) /* not -q */
+		if (!(opt & OPT_q))
 			printf("Script done, file is %s\n", fname);
 		return EXIT_SUCCESS;
 	}

--- busybox-1.12.0/util-linux/Config.in
+++ busybox-1.12.0/util-linux/Config.in
@@ -719,6 +719,13 @@
 	help
 	  This allows you to parse /proc/profile for basic profiling.
 
+config REPLAY
+	bool "replay"
+	default n
+	help
+	  This program replays a typescript, using timing information
+	  given by script -t.
+
 config RTCWAKE
 	bool "rtcwake"
 	default n

--- busybox-1.12.0/util-linux/Kbuild
+++ busybox-1.12.0/util-linux/Kbuild
@@ -28,6 +28,7 @@
 lib-$(CONFIG_RDATE)             += rdate.o
 lib-$(CONFIG_RDEV)              += rdev.o
 lib-$(CONFIG_READPROFILE)       += readprofile.o
+lib-$(CONFIG_REPLAY)            += replay.o
 lib-$(CONFIG_RTCWAKE)           += rtcwake.o
 lib-$(CONFIG_SCRIPT)            += script.o
 lib-$(CONFIG_SETARCH)           += setarch.o

--- busybox-1.12.0/include/applets.h
+++ busybox-1.12.0/include/applets.h
@@ -294,6 +294,7 @@
 USE_REALPATH(APPLET(realpath, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
 USE_HALT(APPLET_ODDNAME(reboot, halt, _BB_DIR_SBIN, _BB_SUID_NEVER, reboot))
 USE_RENICE(APPLET(renice, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
+USE_REPLAY(APPLET(replay, _BB_DIR_BIN, _BB_SUID_NEVER))
 USE_RESET(APPLET(reset, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
 USE_RESIZE(APPLET(resize, _BB_DIR_USR_BIN, _BB_SUID_NEVER))
 USE_RESTORECON(APPLET_ODDNAME(restorecon, setfiles, _BB_DIR_SBIN, _BB_SUID_NEVER, restorecon))

--- busybox-1.12.0/include/usage.h
+++ busybox-1.12.0/include/usage.h
@@ -3244,6 +3244,11 @@
      "\n	-g	Process group id(s)" \
      "\n	-u	Process user name(s) and/or id(s)" \
 
+#define replay_trivial_usage \
+       "timingfile [typescript [divisor]]"
+#define replay_full_usage "\n\n" \
+       "Play back typescripts, using timing information"
+
 #define reset_trivial_usage \
        ""
 #define reset_full_usage "\n\n" \
@@ -3426,13 +3431,20 @@
 
 #define script_trivial_usage \
        "[-afq] [-c COMMAND] [OUTFILE]"
-#define script_full_usage "\n\n" \
+#define script_full_usage_base "\n\n" \
        "Options:" \
      "\n	-a	Append output" \
      "\n	-c	Run COMMAND, not shell" \
      "\n	-f	Flush output after each write" \
      "\n	-q	Quiet" \
 
+#ifdef USE_REPLAY
+#define script_full_usage script_full_usage_base \
+     "\n	-t	Send timing to stderr"
+#else
+#define script_full_usage script_full_usage_base
+#endif
+
 #define sed_trivial_usage \
        "[-efinr] pattern [files...]"
 #define sed_full_usage "\n\n" \

--- busybox-1.12.0/util-linux/replay.c
+++ busybox-1.12.0/util-linux/replay.c
@@ -0,0 +1,41 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * replay - play back typescripts, using timing information
+ *
+ * pascal.bellard@ads-lu.com
+ *
+ * Licensed under GPLv2 or later, see file License in this tarball for details.
+ *
+ */
+
+#include "libbb.h"
+
+int replay_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int replay_main(int argc, char **argv)
+{
+	const char *script = "typescript";
+	double delay, factor = 1000000.0;
+	int fd;
+	long count;
+	FILE *tfp;
+
+	switch (argc) {
+	case 4: factor /= atof(argv[3]);
+	case 3: script = argv[2];
+	case 2:	break;
+	default:
+		bb_show_usage();
+	}
+
+	tfp = xfopen_for_read(argv[1]);
+	fd = open(script, O_RDONLY);
+	while (fscanf(tfp, "%lf %ld\n", &delay, &count) == 2) {
+		usleep(delay * factor);
+		bb_copyfd_exact_size(fd, STDOUT_FILENO, count);
+	}
+#if ENABLE_FEATURE_CLEAN_UP
+	close(fd);
+	fclose(tfp);
+#endif
+	return EXIT_SUCCESS;
+}
