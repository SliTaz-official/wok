diff -purN busybox-1.10.0/archival/Config.in busybox/archival/Config.in
--- busybox-1.10.0/archival/Config.in	2008-03-29 21:47:37.000000000 +0100
+++ busybox-1.10.0/archival/Config.in	2008-03-29 21:47:37.000000000 +0100
@@ -78,6 +78,14 @@ config CPIO
 	  Unless you have a specific application which requires cpio, you should
 	  probably say N here.
 
+config FEATURE_CPIO_O
+	bool "Support for archive creation"
+	default n
+	depends on CPIO
+	help
+	  This implementation of cpio can create cpio archives in the "newc"
+	  format only.
+
 config DPKG
 	bool "dpkg"
 	default n
diff -purN busybox-1.10.0/archival/cpio.c busybox/archival/cpio.c
--- busybox-1.10.0/archival/cpio.c	2008-03-29 21:47:55.000000000 +0100
+++ busybox-1.10.0/archival/cpio.c	2008-03-29 21:47:55.000000000 +0100
@@ -21,12 +21,146 @@
 #define CPIO_OPT_FILE                   0x10
 #define CPIO_OPT_CREATE_LEADING_DIR     0x20
 #define CPIO_OPT_PRESERVE_MTIME         0x40
+#define CPIO_OPT_CREATE                 0x80
+#define CPIO_OPT_FORMAT                0x100
+
+#if ENABLE_FEATURE_CPIO_O
+static void cpio_pad(off_t *size, int n)
+{
+    int i;
+    for (*size += i = (-*size) & n; --i >= 0; bb_putchar(0));
+}
+
+static void cpio_o(void)
+{
+    struct name_s {
+        struct name_s *next;
+        char name[0];
+    };
+    struct inodes_s {
+        struct name_s *names;
+        struct inodes_s *next;
+        struct stat st;
+    } *links = NULL;
+    off_t bytes = 0; // output bytes count
+#if CONFIG_FEATURE_COPYBUF_KB < 1
+    char buf[1024];
+#else
+    char buf[CONFIG_FEATURE_COPYBUF_KB * 1024];
+#endif
+	
+    while (1) {
+        const char *name = "TRAILER!!!";
+        char *line = xmalloc_getline(stdin);
+        // allocate inode struct each loop to avoid struct stat copy
+        struct inodes_s *inode = xzalloc(sizeof(*inode)); // die if fail
+
+        inode->st.st_nlink++; // =1
+        if (line) {
+            /* Strip leading `./' from the filename.  */
+            for (name = line; name[0] == '.' && name[1] == '/';) {
+                while (*++name == '/');
+            }
+            if (!*name) goto free_and_continue; // line empty
+            if (lstat(name, &inode->st)) {
+          abort_cpio_o:
+                bb_perror_msg_and_die(name);
+            }
+        }
+
+        // hard links will are stored and will be processed later
+        if (!S_ISDIR(inode->st.st_mode) && inode->st.st_nlink > 1) {
+            struct name_s *n;
+            struct inodes_s *l;
+
+            for (l = links; l && l->st.st_ino != inode->st.st_ino; l = l->next);
+            if (l == NULL) { // not found: new hard links set
+                l = inode; // l->names = NULL; l->st = inode->st
+                l->next = links;
+                links = l;
+            }
+            n = xmalloc(sizeof(*n) + strlen(name) + 1); // die if fail
+            strcpy(n->name, name);
+            n->next = l->names;
+            l->names = n; // will not free inode if l == inode
+            goto free_and_continue;
+        }
+
+        // no more files ? process hard links
+        if (!line && links) {
+            struct name_s *n;
+
+            free(inode); // trailer pseudo inode
+            inode = links;
+            n = links->names;
+            name = line = xstrdup(n->name);    // line will free *name memory
+            links->names = n->next;
+            if (links->names == NULL)          // inode will free *links memory
+                links = links->next;
+            else links->st.st_size = 0;        // not last link: no data
+            free(n);
+        }
+
+        bytes += printf("070701%08lx%08lx%08lx%08lx%08lx%08lx%08lx"
+                        "%08lx%08lx%08lx%08lx%08lx%08lx%s%c",
+                        (unsigned long) inode->st.st_ino,
+                        (unsigned long) inode->st.st_mode, 
+                        (unsigned long) inode->st.st_uid,
+                        (unsigned long) inode->st.st_gid,
+                        (unsigned long) inode->st.st_nlink,
+                        (unsigned long) inode->st.st_mtime,
+                        (unsigned long) inode->st.st_size,
+                        (unsigned long) major(inode->st.st_dev),
+                        (unsigned long) minor(inode->st.st_dev),
+                        (unsigned long) major(inode->st.st_rdev), 
+                        (unsigned long) minor(inode->st.st_rdev),
+                        strlen(name) + 1UL, 0UL, name, 0);
+
+        cpio_pad(&bytes, (line) ? 4-1 : 512-1);
+
+        if (inode->st.st_size) {
+
+            if (S_ISLNK(inode->st.st_mode)) {
+                char *lpath = xmalloc_readlink_or_warn(name);
+
+                if (!lpath) goto abort_cpio_o;
+                bytes += printf("%s", lpath);
+                free(lpath);
+            }
+
+            if (S_ISREG(inode->st.st_mode)) {
+                int fd = open_or_warn(name, O_RDONLY);
+
+                while (1) {
+                    int len = full_read(fd, buf, sizeof(buf));
+                    if (len < 0) goto abort_cpio_o;
+                    if (len == 0) break;
+                    bytes += len;
+                    fwrite(buf, 1, len, stdout);
+                }
+                close(fd);
+            }
+
+            cpio_pad(&bytes, 4-1);
+        }
+
+        if (!line) return; // was trailer
+
+    free_and_continue:
+        if (!inode->names) free(inode);
+            free(line);
+    }
+}
+#endif
 
 int cpio_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int cpio_main(int argc, char **argv)
 {
 	archive_handle_t *archive_handle;
 	char *cpio_filename = NULL;
+#if ENABLE_FEATURE_CPIO_O
+	const char *cpio_fmt = "";
+#endif
 	unsigned opt;
 
 	/* Initialise */
@@ -35,10 +169,26 @@ int cpio_main(int argc, char **argv)
 	archive_handle->seek = seek_by_read;
 	archive_handle->flags = ARCHIVE_EXTRACT_NEWER | ARCHIVE_PRESERVE_DATE;
 
+#if ENABLE_FEATURE_CPIO_O
+	opt = getopt32(argv, "ituvF:dmoH:", &cpio_filename,&cpio_fmt);
+
+	if (opt & CPIO_OPT_CREATE) {
+		if (*cpio_fmt != 'n')
+			goto cpio_show_usage;
+		if (cpio_filename) {
+			fclose(stdout);
+			stdout = fopen(cpio_filename,"w");
+		}
+		cpio_o();
+		return EXIT_SUCCESS;
+	}
+#else
 	opt = getopt32(argv, "ituvF:dm", &cpio_filename);
+#endif
 
 	/* One of either extract or test options must be given */
 	if ((opt & (CPIO_OPT_TEST | CPIO_OPT_EXTRACT)) == 0) {
+ cpio_show_usage:
 		bb_show_usage();
 	}
 
diff -purN busybox-1.10.0/include/usage.h busybox/include/usage.h
--- busybox-1.10.0/include/usage.h	2008-03-29 21:48:22.000000000 +0100
+++ busybox-1.10.0/include/usage.h	2008-03-29 21:48:22.000000000 +0100
@@ -496,13 +496,19 @@
      "\n	-l,-s	Create (sym)links" \
 
 #define cpio_trivial_usage \
-       "-[dimtuv][F cpiofile]"
+       "-[dim" USE_FEATURE_CPIO_O("o") "tuv][F cpiofile]" \
+       USE_FEATURE_CPIO_O( "[H newc]" ) 
 #define cpio_full_usage \
-       "Extract or list files from a cpio archive\n" \
+       "Extract or list files from a cpio archive" \
+       USE_FEATURE_CPIO_O( ", or create a cpio archive" ) "\n" \
        "Main operation mode:" \
      "\n	d	Make leading directories" \
      "\n	i	Extract" \
      "\n	m	Preserve mtime" \
+       USE_FEATURE_CPIO_O( \
+     "\n	o	Create" \
+     "\n	H newc	Define format" \
+       ) \
      "\n	t	List" \
      "\n	v	Verbose" \
      "\n	u	Unconditional overwrite" \
