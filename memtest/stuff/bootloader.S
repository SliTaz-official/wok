// Image/zImage boot sector

SYSSEG		= 0x1000
INITSEG		= 0x9000
SETUPSEG	= 0x9020
setup_sects	= 497
syssize		= 500

	.text
	.code16
	.org	0
	.globl	_start
_start:

#define CODESZ 512		/* patched by installer */

/* some extra features */
#define EXE_SUPPORT		real mode dos .exe file support
#define CMDLINE		0x9E00
#define VCPI			VCPI 4.0 support
#define SHUTDOWNDOS		shutdown DOS services

/* some contraints to reduce the size */
//#define FLOPPY_1440K_ONLY	1.44M floppies support only	-33
//#define FLOPPY_HAS_2_SIDES	hardcoded heads count to 2	-13
//#define MOVE_MAX_SYSSIZE	always memcpy 512Kb		-2
//#define NO_CURSOR_DEFINITION					-8
//#define NO_CMDLINE_SHRINK	remove heading spaces ?		-6
//#define NO_DOTS		show progression dots ?		-8

#ifdef EXE_SUPPORT
#define EXEADRS(x)	(x+0xE0)
#define FLAT20(x)	(x+16*INITSEG)

.macro	trace_int19
	pushl	$4
	popw	%si
	popw	%ds
	pushl	(%si)
	movl	$step19+(INITSEG<<16), (%si)
	pushfw
	popw	%ax
	incb	%ah			# set TF
	pushw	%ax
	popfw
	ljmp	*4*0x19-4(%si)
.endm

stacktop	= 0x9E00		# in 0x8000 .. 0xA000
	decw	%bp			// Magic number: MZ
	popw	%dx
	jmp	start			// Bytes on last page of file
	.word	(CODESZ+511)/512	// Pages in file			INSTALLER
	.word	0			// Relocations
	.word	(end_header-_start)/16	// Size of header in paragraphs
	.word	(CODESZ+stacktop+15)/16	// Minimum extra paragraphs needed	INSTALLER
	.word	-1			// Maximum extra paragraphs needed
	.word	(CODESZ+15)/16		// Initial (relative) SS value		INSTALLER
	.word	stacktop		// Initial SP value
	.word	0			// Checksum				INSTALLER?
	.word	EXEADRS(comstart)	// Initial IP value
	.word	0xFFF0			// Initial (relative) CS value
//	.word	0x001C			// File address of relocation table
//	.word	0,0,0			// Overlay number
#endif
start:
	cld				# assume nothing
	xorw	%ax, %ax		# %ax = 0
zeroed		= 12			# zeroed registers
stacktop	= 0x9E00		# in 0x8000 .. 0xA000 (+zeroed+12)
	pushw	$INITSEG
	popw	%ss			# %ss contain INITSEG
	pushw	%ss
end_header:
	popw	%es			# %es = %ss = INITSEG
					# cmdline offset at 0x22
	movw	$stacktop, %di		# stacktop is an arbitrary value >=
					# length of bootsect + length of
					# setup + room for stack;
					# 12 is disk parm size.
	movw	%di, %sp		# put stack at INITSEG:stacktop-...
#ifdef EXE_SUPPORT
	cwd				# %dx = 0
#endif

# Many BIOS's default disk parameter tables will not recognize
# multi-sector reads beyond the maximum sector number specified
# in the default diskette parameter tables - this may mean 7
# sectors in some cases.
#
# Since single sector reads are slow and out of the question,
# we must take care of this by creating new parameter tables
# (for the first disk) in RAM.  We can set the maximum sector
# count to 36 - the most we will encounter on an ED 2.88.  
#
# High doesn't hurt.  Low does.  Let's use the max: 63

	movw	$zeroed/2, %cx		# clear gdt + offset, %ds, limits
	rep				# don't worry about cld
	stosw				# already done above
	popw	%bx			# offset = 0
	popw	%ds			# %ds = 0
	popw	%fs			# %fs = 0

	movb	setup_sects+0x7C00, %al	# read bootsector + setup (%ds = 0)
	incw	%ax

	ldsw	0x78(%bx), %si		# %ds:%bx+0x78 is parameter table address
	pushw	%es
	pushw	%di
	movb	$6, %cl			# copy 12 bytes
	rep				# don't worry about cld
	movsw				# already done above
	pushw	%ss
	popw	%ds			# now %ds = %es = %ss = INITSEG
	popl	%fs:0x78(%bx)		# update parameter table address
	movb	$63, 0x4-12(%di)	# patch sector count, %di = stacktop
	cli

	xchg	%ax, %di		# sector count
	popw	%ax			# limits = 0
	incw	%cx			# cylinder 0, sector 1, clear Z
	call	read_first_sectors	# read setup

# This routine loads the system at address LOADSEG, making sure
# no 64kB boundaries are crossed. We try to load it as fast as
# possible, loading whole tracks whenever we can.

#ifndef NO_DOTS
	popw	%bx			# clear %bx
#endif
	movw	syssize, %di
	decw	%di
	shrw	$9-4, %di
	incw	%di
	movw	$SYSSEG, %cx
	call	read_sectorsCX

# This procedure turns off the floppy drive motor, so
# that we enter the kernel in a known state, and
# don't have to worry about it later.

kill_motor:
	xchgw	%ax, %di		# reset FDC (%di < 128)
	int	$0x13

# After that (everything loaded), we jump to the setup-routine
# loaded directly after the bootblock:
# Segments are as follows: %ds = %ss = INITSEG

jmp_setup:
	ljmp	$SETUPSEG, $0

#ifdef EXE_SUPPORT
#ifdef SHUTDOWNDOS
doiret:
	iret
step19:
	pushw	%si
	pushw	%ds
	movw	%sp, %si
	ldsw	%ss:4(%si), %si
	cmpw	$0x19CD, (%si)
	popw    %ds
	popw    %si
	jne	doiret
	xorw	%si, %si
	movw	%si, %ds
	pushw	%cs
	popw	%ss
	movw	$stacktop-4-16, %sp
	popl	4(%si)
	popaw
#endif
movesys:				// %ax = SYSSEG, %bx = DS, %si
	//movw	%cs:syssize, %bp
	movw	$0x8000, %bp
	shrw	$4, %si
	addw	%si, %bx
	subw	%ax, %bx
	jnc	forward
	addw	%bp, %ax
forward:
	movw	%ax, %es
	movw	%ax, %dx
	addw	%bx, %dx
	movw	%dx, %ds
	sbbw	%dx, %dx		// %dx = 0 : -1
	cmc				//  C  = 1 :  0
	adcw	%dx, %ax
	xorw	%si, %si
	xorw	%di, %di
	movb	$8, %cl
	rep
	  movsw
	decw	%bp
	jns	forward
#ifndef NO_CURSOR_DEFINITION
	movb	$1, %ah
	movb	$0, %bh
	movb	$0x20, %ch	// 0x2000
	int	$0x10
#endif
	pushw	%ss
	popw	%ds
	jmp	jmp_setup
comstart:
	cld				# assume nothing
	pushw	$INITSEG
	popw	%es
#ifdef CMDLINE
	movw	%sp, %di
	movw	$0x80, %si
	lodsb
	cbw
	xchgw	%ax, %cx
	jcxz	nocmdline
	movw	$0xA33F, 0x7F(%si)
# ifndef NO_CMDLINE_SHRINK
skipspace:
	lodsb
	cmpb	$0x20, %al
	je	skipspace
	decw	%si
# endif
	rep
	  movsb
nocmdline:
#endif
	movb	$(512-(end_header-_start))/2, %cl
	movb	EXEADRS(setup_sects), %ch
	movw	$0x100, %si
	movw	$end_header, %di
	rep
	  movsw
	movw	$SYSSEG, %ax
	movw	%ds, %bx
	pushw	%es
	popw	%ss
#ifndef SHUTDOWNDOS
	pushw	%es
	pushw	$movesys
#endif
#ifdef VCPI
# ifndef SHUTDOWNDOS
	pushw	%es
	pushw	%ds
# endif
	pushaw
	smsww	%ax
	andb	$1, %al
	je	isrm
	movw	$EXEADRS(gdt_vcpi),%si
	pushw	$pagebuf/16
	popw	%es
	movl	$pagebuf+3,%es:0x1000
	xorw	%di,%di
call_vcpi:
	movb	$0xDE,%ah	// DE01, EBX = getiface(DS:SI, ES:DI)
	int	$0x67
	movl	$FLAT20(sw2pm_params),%esi
	movb	$0x0C,%al	// DE0C switchpm(ESI)
	cli
	jmp	call_vcpi
pm_code:
	movl	%cr0,%eax
	andl	$0x7FFFFFFE,%eax
	movl	%eax,%cr0
	movl	%eax,%cr3
isrm:
# ifdef SHUTDOWNDOS
	trace_int19
# else
	lssw	%cs:EXEADRS(saved_ss_sp),%sp	
	popaw
	popw	%ds
	popw	%es
	retf
# endif
#else
# ifdef SHUTDOWNDOS
	pushaw
	trace_int19
# endif
	retf
#endif
#endif

# read_sectors reads %di sectors into %es:0 buffer.
# %es:0 is updated to the next memory location.
# First, sectors are read sector by sector until
# sector per track count is known. Then they are
# read track by track.
# Assume no error on first track.

#ifdef FLOPPY_1440K_ONLY
#define FLOPPY_HAS_2_SIDES	hardcore heads count to 2
#define FLOPPY_SECTORS		18	/* 18 sectors */
#else
#define FLOPPY_HEADS		2	/* 2 heads minimum */
#define FLOPPY_SECTORS		9	/* 9 sectors minimum */
#endif

return:
#ifndef NO_DOTS
	movw	$0xE2E,%ax
	movb	$7,%bl
	int	$0x10
#endif
	ret

check_limits:
#ifndef FLOPPY_1440K_ONLY
	popw	%dx
#ifdef FLOPPY_SECTORS
	cmpb	$FLOPPY_SECTORS+1, %cl	# minimum sector count
	jb	check_head
#endif
        cmpb    %al, %cl		# max sector known ?
        ja	next_head		#   no -> store it
#ifndef FLOPPY_HAS_2_SIDES
check_head:
#ifdef FLOPPY_HEADS
	cmpb	$FLOPPY_HEADS, %dh	# 2 heads minimum
	jb	check_cylinder
#endif
        cmpb    %ah, %dh		# max head known ?
        ja	next_cylinder		#   no -> store it
check_cylinder:
#endif
#endif
	pushaw
#ifndef FLOPPY_1440K_ONLY
	cbw				# %ah = 0
#endif
        int     $0x13			# reset controler
	popaw
	movb	$1, %al			# sector by sector...
read_sectorslp:
	pushw	%dx			# some bios break dx...
#ifndef FLOPPY_1440K_ONLY
        pushw   %ax			# limits
	subb	%cl, %al		# sectors remaining in track
	ja	tolastsect
	movb	$1, %al			# 1 sector mini
tolastsect:
#else
	movb	$FLOPPY_SECTORS+1, %al
	subb	%cl, %al		# sectors remaining in track
#endif
	cbw
	cmpw	%di, %ax
	jb	more1trk
	movw	%di, %ax		# sectors to read
more1trk:
	pushw	%ax			# save context
	movb	$2, %ah			# cmd: read chs
        int     $0x13
#ifndef FLOPPY_1440K_ONLY
	popw	%dx			# save %ax
        popw    %ax			# limits
#else
	popw	%ax			# restore context
	popw	%dx
#endif
	jc	check_limits
#ifndef FLOPPY_1440K_ONLY
	xchgw	%ax, %bp
	addw	%dx,%cx			# next sector
	movw	%cx, %gs
	movw	%es, %cx
	pushw	%dx
	shlw	$5, %dx
	addw	%dx, %cx
	popw	%dx
	subw	%dx,%di			# update sector counter
	popw	%dx
#else
	addw	%ax,%cx			# next sector
	movw	%cx, %gs
	movw	%es, %cx
	pushw	%ax
	shlw	$5, %ax
	addw	%ax, %cx
	popw	%ax
	subw	%ax,%di			# update sector counter
#endif
read_sectorsCX:
	movw	%cx, %es		# next location
	jz	return
read_sectors:
	movw	%gs, %cx
#ifndef FLOPPY_1440K_ONLY
#   al is last sector+1
#   ah is last cylinder+1
	xchgw	%ax, %bp
#endif
#ifndef FLOPPY_1440K_ONLY
        cmpb    %al,%cl			# reach sector limit ?
        jne     bdendlp
next_head:
        movb    %cl,%al
#else
        cmpb    $FLOPPY_SECTORS+1,%cl	# reach sector limit ?
        jne     bdendlp
#endif
        movb    $1,%cl			# first sector
#ifndef FLOPPY_HAS_2_SIDES
        incb    %dh			# next head
        cmpb    %ah, %dh		# reach head limit ?
        jne     bdendlp
next_cylinder:
        movb    %dh,%ah
        movb    $0,%dh			# first head
#else
        xorb    %cl,%dh			# next head
        jne	bdendlp			# reach head limit ?
#endif
# NOTE : support 256 cylinders max
        incb    %ch			# next cylinder
read_first_sectors:
bdendlp:
        jmp	read_sectorslp

#ifdef VCPI
pagebuf		=	0x98000
tss		=	gdt_abs-40
gdt		=	gdt_abs-32
gdt_null	=	gdt_abs-32
gdt_vcpi	=	gdt_abs-24
gdt_vcpi2	=	gdt_abs-16
gdt_vcpi3	=	gdt_abs-8
gdt_abs:
	.word	0xFFFF
	.long	0x92000000
	.byte	0xCF,0
gdt_code:
	.word	0xFFFF
gdt_code_base:
	.long	0x9A000000+FLAT20(0)
	.byte	0x8F,0
gdt_tss:
	.word	0x00FF
gdt_tss_base:
	.long	0x89000000+FLAT20(tss)
	.byte	0,0
gdtr:
gdt_lim:
	.word	0xFFFF
gdt_base:
	.long	FLAT20(gdt)
sw2pm_params:
sw2pm_cr3:
	.long	pagebuf+0x1000
sw2pm_gdtr_ptr:
	.long	FLAT20(gdtr)
sw2pm_idtr_ptr:
	.long	FLAT20(idtr)
sw2pm_ldtr:
	.word	0
sw2pm_tr:
SEL_TSS		= gdt_tss-gdt_null
	.word	SEL_TSS
sw2pm_jumpaddr:
	.long	pm_code
SEL_CODE	= gdt_code-gdt_null
	.word	SEL_CODE
idtr:
idt_lim:
	.word	0x03FF
idt_base:
	.long	0
# ifndef SHUTDOWNDOS
saved_ss_sp:
	.word	stacktop-4-16-4,INITSEG
# endif
#endif

helpmsg:
	.ascii	"SliTaz zImage boot"
	.org 497
helpend:
