# SliTaz package receipt.

PACKAGE="linux"
VERSION="2.6.34"
CATEGORY="base-system"
SHORT_DESC="The Linux kernel and modules."
DEPENDS="depmod"
BUILD_DEPENDS="slitaz-toolchain perl git"
MAINTAINER="devel@slitaz.org"
TARBALL="$PACKAGE-$VERSION.tar.bz2"
WEB_SITE="http://www.kernel.org/"
WGET_URL="http://www.eu.kernel.org/pub/linux/kernel/v${VERSION:0:3}/$TARBALL"
CONFIG_FILES="/lib/modules/$VERSION-slitaz/modules.dep"

# Rules to configure and make the package.
compile_rules()
{
	# Aufs2 from git repository
	if [ ! -d aufs2 ]; then
		git clone http://git.c3sl.ufpr.br/pub/scm/aufs/aufs2-standalone.git aufs2
		cd aufs2 && git checkout origin/aufs2-34
	fi
	cd aufs2
	cp -a Documentation fs include $src
	cp -a *.patch ../stuff
	# We need the real GNU patch
	[ -L /usr/bin/patch ] && tazpkg get-install patch --forced
	cd $src
	# SliTaz db
	rm -rf slitaz 2> /dev/null
	mkdir slitaz
	echo "$WGET_URL" > slitaz/url
	cp ../stuff/gztazmod.sh ../stuff/list_modules.sh slitaz
	cp ../stuff/bootloader.sh slitaz
	# Apply patches
	while read patch_file; do
		echo "$patch_file" >> slitaz/patches
		cp ../stuff/$patch_file slitaz
		if [ -f done.$patch_file ]; then
			echo "Skipping $patch_file"
			continue
		fi
		echo "Apply $patch_file"
		patch -p1 < slitaz/$patch_file || exit 1
		touch done.$patch_file
	done <<EOT
$PACKAGE-diff-$VERSION.u
$PACKAGE-unlzma-$VERSION.u
$PACKAGE-header-$VERSION.u
aufs2-base.patch
aufs2-kbuild.patch
aufs2-standalone.patch
$PACKAGE-freeinitrd-$VERSION.u
$PACKAGE-squashfs-lzma-$VERSION.u
EOT
	make mrproper
	cd Documentation/lguest
	make lguest || return 1
	cd ../..
	cp ../stuff/$PACKAGE-$VERSION-slitaz.config .config
	make oldconfig
	ln .config slitaz/config
	make -j 4 bzImage &&
	make -j 4 modules &&
	make INSTALL_MOD_PATH=$PWD/_pkg modules_install &&
	make INSTALL_HDR_PATH=$PWD/_pkg/usr headers_install &&
	[ -s arch/x86/boot/bzImage ]
}

# Rules to gen a SliTaz package suitable for Tazpkg.
genpkg_rules()
{
    local path
    mkdir $fs/boot
    cp -a $src/arch/x86/boot/bzImage \
		$fs/boot/vmlinuz-$VERSION-slitaz
    # Compress all modules.
    ./stuff/gztazmod.sh $_pkg/lib/modules/$VERSION-slitaz
    path=$fs/lib/modules/$VERSION-slitaz/kernel
    mkdir -p $path
    cp -a $_pkg/lib/modules/$VERSION-slitaz/mo* \
		$fs/lib/modules/$VERSION-slitaz
    # Get the base modules
    export src
    export _pkg
    $src/slitaz/list_modules.sh \
	$(cat stuff/modules-$VERSION.list) > $src/modules.list
    while read module; do
    	dir=$(dirname $module)
    	[ -d $path/$dir ] || mkdir -p $path/$dir
        cp -a $_pkg/lib/modules/$VERSION-slitaz/kernel/$module $path/$dir
    done < $src/modules.list
    # Remove unresolved links
    rm -f $fs/lib/modules/$VERSION-slitaz/build
    rm -f $fs/lib/modules/$VERSION-slitaz/source
    # Package all wanted linux pkgs
    for i in $(cd $WOK; grep -l 'WANTED="linux"$')
    do
    	tazwok genpkg $i
    done
    # Cook all packages with a kernel module
    for i in $(cd $WOK; grep -l 'tazwok cook linux$' */receipt)
    do
    	echo tazwok cook ${i%/receipt}
    done
    # Check and echo any module in kernel .config that's not added to 
    # one of linux-* pkgs
	./stuff/check_modules.sh 
}

# Pre and post install commands for Tazpkg.
post_install()
{
    echo "Processing post-install commands..."
    chroot "$1/" depmod -a $VERSION-slitaz
    # GRUB stuff.
    if [ -f "$1/boot/grub/menu.lst" ]; then
    	root_dev=`cat $1/boot/grub/menu.lst | grep root= | sed 's/.*root=\([^ ]*\).*/\1/' | head -n 1`
		grub_dev=`cat $1/boot/grub/menu.lst | grep "root (" | head -n 1`
		# Add new kernel entry in case of upgrade for installed system.
		if ! grep -q $PACKAGE-$VERSION-slitaz $1/boot/grub/menu.lst; then
    		cat >> $1/boot/grub/menu.lst << EOT

title SliTaz GNU/Linux (Kernel $VERSION-slitaz)
$grub_dev
kernel /boot/vmlinuz-$VERSION-slitaz root=$root_dev
EOT
		fi
		# Display information message.
    	cat <<EOT
----
GRUB is installed, these tree lines must be in your /boot/grub/menu.lst:

title  SliTaz GNU/Linux (Kernel $VERSION-slitaz)
$grub_dev
kernel /boot/vmlinuz-$VERSION-slitaz root=$root_dev
----
EOT
	fi
}

clean_wok()
{
	rm -rf aufs2
	rm stuff/aufs2-*
	rm -rf stuff/tmp
}
