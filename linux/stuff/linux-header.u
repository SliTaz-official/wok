--- linux-3.2.14/arch/x86/boot/header.S
+++ linux-3.2.14/arch/x86/boot/header.S
@@ -7,6 +7,7 @@
  *	modified by more people than can be counted
  *
  *	Rewritten as a common file by H. Peter Anvin (Apr 2007)
+ *	Rewritten Pascal Bellard (Nov 2009)
  *
  * BIG FAT NOTE: We're in real mode using 64k segments.  Therefore segment
  * addresses must be multiplied by 16 to obtain their respective linear
@@ -27,7 +28,12 @@
 
 BOOTSEG		= 0x07C0		/* original address of boot-sector */
 SYSSEG		= 0x1000		/* historical load address >> 4 */
+INITSEG		= 0x9000		/* boot address >> 4 */
+SETUPSEG	= 0x9020		/* setup address >> 4 */
 
+#define LOADSEG	 0x0800
+#define LOADSZ	 (LOADSEG*0x10)
+
 #ifndef SVGA_MODE
 #define SVGA_MODE ASK_VGA
 #endif
@@ -45,48 +51,366 @@
 
 	.global bootsect_start
 bootsect_start:
+	cld				# assume nothing
+stacktop	= 0x9E00		# in 0x8000 .. 0xA000
+zeroed		= 48+12			# gdt + zeroed registers
+	movw	$stacktop-12-zeroed, %di	# stacktop is an arbitrary value >=
+					# length of bootsect + length of
+					# setup + room for stack;
+					# 12 is disk parm size.
+	pushw	$INITSEG
+	popw	%ss			# %ss contain INITSEG
+	movw	%di, %sp		# put stack at INITSEG:stacktop-...
 
-	# Normalize the start address
-	ljmp	$BOOTSEG, $start2
+# Many BIOS's default disk parameter tables will not recognize
+# multi-sector reads beyond the maximum sector number specified
+# in the default diskette parameter tables - this may mean 7
+# sectors in some cases.
+#
+# Since single sector reads are slow and out of the question,
+# we must take care of this by creating new parameter tables
+# (for the first disk) in RAM.  We can set the maximum sector
+# count to 36 - the most we will encounter on an ED 2.88.  
+#
+# High doesn't hurt.  Low does.  Let's use the max: 63
 
-start2:
-	movw	%cs, %ax
-	movw	%ax, %ds
-	movw	%ax, %es
-	movw	%ax, %ss
-	xorw	%sp, %sp
-	sti
-	cld
+	pushw	%ss
+	popw	%es			# %es = %ss = INITSEG
+	xorw	%ax, %ax		# %ax = 0
+	movw	$zeroed/2, %cx		# clear gdt + offset, %ds, limits
+	rep				# don't worry about cld
+	stosw				# already done above
+	popw	%bx			# offset = 0
+	popw	%ds			# %ds = 0
+	popw	%fs			# %fs = 0
 
-	movw	$bugger_off_msg, %si
+	movb	setup_sects+0x7C00, %al	# read bootsector + setup (%ds = 0)
+	incw	%ax
 
-msg_loop:
-	lodsb
-	andb	%al, %al
-	jz	bs_die
-	movb	$0xe, %ah
-	movw	$7, %bx
+	ldsw	0x78(%bx), %si		# %ds:%bx+0x78 is parameter table address
+	pushw	%es
+	pushw	%di
+	movb	$6, %cl			# copy 12 bytes
+	rep				# don't worry about cld
+	movsw				# already done above
+	pushw	%ss
+	popw	%ds			# now %ds = %es = %ss = INITSEG
+	popl	%fs:0x78(%bx)		# update parameter table address
+	movb	$63, 0x4-12(%di)	# patch sector count, %di = stacktop
+	cli
+
+	xchg	%ax, %di		# sector count
+	popw	%ax			# limits = 0
+	incw	%cx			# cylinder 0, sector 1, clear Z
+	call	read_first_sectors	# read setup
+
+	movw	$0x200,%si
+#define kernel_version	0xE
+type_of_loader	=	0x10
+loadflags	=	0x11
+heap_end_ptr	=	0x24
+	orw	$0x8020, type_of_loader(%si) # loader type = 0x20 = bootsect-loader
+	movb	$(stacktop-0x300)/256, heap_end_ptr+1(%si)
+	addw	kernel_version(%si),%si	# starting protocol 2.00, Kernel 1.3.73
+	call	puts			# show which kernel we are loading
+
+# The cmdline can be entered and modifed at boot time.
+# Only characters before the cursor are passed to the kernel.
+	popw	%bx			# clear %bx
+	orw	cmd_line_ptr, %bx
+	jz	nocmdline
+	pushw	%bx
+	incw	%di
+	call	read_sectors
+	popw	%si
+	call	puts
+cmdlp:
+	movb	$0x20, %al		# clear end of line
+	int	$0x10			#  with Space
+	movb	$8, %al			#   and BackSpace
 	int	$0x10
-	jmp	msg_loop
+	decw	%si
+cmdget:
+	call	wait4key
+	cmpb	$8, %al			# BackSpace ?
+	je	cmdbs
+	movb	%al, (%si)		# store char
+	lodsw				# %si += 2
+cmdbs:
+	cmpw	%si,cmd_line_ptr
+	je	cmdget
+	call	putc			# set %ah and %bx
+	cmpb	$10, %al		# Enter ?
+	jne	cmdlp
+	movb	%bh,-2(%si)		# set end of string and remove CR
+endcmdline:
+nocmdline:
 
-bs_die:
-	# Allow the user to press a key, then reboot
-	xorw	%ax, %ax
-	int	$0x16
-	int	$0x19
+# This routine loads the system at address LOADSEG, making sure
+# no 64kB boundaries are crossed. We try to load it as fast as
+# possible, loading whole tracks whenever we can.
 
-	# int 0x19 should never return.  In case it does anyway,
-	# invoke the BIOS reset code...
-	ljmp	$0xf000,$0xfff0
+ramdisk_image	=	0x0218
+ramdisk_size	=	0x021C
+bootsect_src_limit	= 16
+bootsect_dst_limit	= 24
+bootsect_src_base	= 18
+bootsect_dst_base	= 26
+	popw	%bx			# clear %bx
+	movw	%sp, %si		# for bootsect_gdt
+init_gdt:
+	decw	bootsect_src_limit(%bx,%si)	# max 64Kb
+	movb	$0x93, bootsect_src_base+3(%bx,%si)
+	xorb	$bootsect_dst_limit-bootsect_src_limit, %bl
+	jne	init_gdt
+	movw	$syssize, %bx
+code32_start	=	0x214
+	movw	code32_start+1, %ax		# destination = 0x00100000 or 0x00010000
+	movb	$5, %cl
+initrdlp:
+	movl	(%bx),%ebx
+	decl	%ebx
+	shrl	%cl, %ebx
+	incw	%bx
+syslp:
+	pushw	$LOADSEG
+	popw	%es
+	movw	$LOADSZ/256,%di		# size in pages
+	movw	%di, bootsect_src_base+1(%si) # assume LOADSZ == LOADSEG*16
+	movw	%ax, bootsect_dst_base+1(%si)
+	addw	%di, %ax		# next dest
+	shrw	$1, %di			# pages to sectors
+	subw	%di, %bx		# max 32M > int 15 limit
+	pushf
+	jnc	not_last
+	addw	%bx, %di
+not_last:
+	pushw	%ax
+	pushw	%di
+	pushw	%si
+	pushw	%bx
+	xorw	%bx,%bx
+	call	read_sectors		# update %bp
+	popw	%bx
+	popw	%si
+	popw	%cx			# sectors to word count:
+	xchgb	%cl, %ch		# %cx <<= 8
+	movb	$0x87, %ah
+	pushw	%ss
+	popw	%es			# restore es
+	int	$0x15			# max 16M
+	popw	%ax
+	popf
+	ja	syslp
+	movw	ramdisk_image+1,%ax
+	movw	$ramdisk_size,%bx
+	movb	$9, %cl
+	cmpw	%ax, bootsect_dst_base+1(%si)
+	jb	initrdlp
 
-	.section ".bsdata", "a"
-bugger_off_msg:
-	.ascii	"Direct booting from floppy is no longer supported.\r\n"
-	.ascii	"Please use a boot loader program instead.\r\n"
-	.ascii	"\n"
-	.ascii	"Remove disk and press any key to reboot . . .\r\n"
-	.byte	0
+# This procedure turns off the floppy drive motor, so
+# that we enter the kernel in a known state, and
+# don't have to worry about it later.
 
+kill_motor:
+	xchgw	%ax, %di		# reset FDC (%di < 128)
+	int	$0x13
+
+# After that (everything loaded), we jump to the setup-routine
+# loaded directly after the bootblock:
+# Segments are as follows: %ds = %ss = INITSEG
+
+	ljmp	$SETUPSEG, $0
+
+# read_sectors reads %di sectors into %es:0 buffer.
+# %es:0 is updated to the next memory location.
+# First, sectors are read sector by sector until
+# sector per track count is known. Then they are
+# read track by track.
+# Assume no error on first track.
+
+#define FLOPPY_CYLINDERS	80	/* 80 cylinders minimum */
+#define FLOPPY_HEADS		2	/* 2 heads minimum */
+#define FLOPPY_SECTORS		18	/* 18 sectors minimum */
+
+print_loop:
+	movb	$0x6 + 'A' - 1, %al
+	subb	%cl, %al
+	movw	$regs, %si		# caller %si is saved
+	call	putcs			# putc(%al) + puts(%si)
+# it will print out all of the registers.
+	popw	%bp			# load word into %si
+	jmp	print_all		# print %bp (status)
+check_limits:
+	cmpb	$FLOPPY_SECTORS+1, %cl	# 18 sectors minimum
+	jb	check_head
+        cmpb    %al, %cl		# max sector known ?
+        ja	next_head		#   no -> store it
+check_head:
+	cmpb	$FLOPPY_HEADS, %dh	# 2 heads minimum
+	jb	check_cylinder
+        cmpb    %ah, %dh		# max head known ?
+        ja	next_cylinder		#   no -> store it
+check_cylinder:
+	pushaw
+	cmpw	$0x600,%bp		# disk changed ?
+	je	reset_floppy
+	pushw	%es			# print %es (named EX)
+	pushw	%dx			# print %dx
+	pushw	%cx			# print %cx
+	pushw	%bx			# print %bx
+	xchgw	%ax, %si
+	movb	$2,%ah
+	pushw	%ax			# print %ax
+	movb	$6,%cl
+print_all:
+	movb	$4, %ch			# 4 hex digits
+print_digit:
+	rolw	$4, %bp			# rotate to use low 4 bits
+	movb	$0x0f, %al
+	andw	%bp, %ax		# %al = mask for nybble
+	addb	$0x90, %al		# convert %al to ascii hex
+	daa				# in only four instructions!
+	adcb	$0x40, %al
+	daa
+	call	putc			# set %ah and %bx
+	decb	%ch
+	jnz	print_digit
+	movb	$0x20, %al		# SPACE
+	int	$0x10
+	loop	print_loop
+	call	wait
+	cbw				# %ah = 0
+reset_floppy:
+        int     $0x13			# reset controler
+	popaw
+read_sectorslp:
+	pushw	%dx			# some bios break dx...
+        pushw   %ax			# limits
+	subb	%cl, %al		# sectors remaining in track
+	ja	tolastsect
+	movb	$1, %al			# 1 sector mini
+tolastsect:
+	cbw
+	cmpw	%di, %ax
+	jb	more1trk
+	movw	%di, %ax		# sectors to read
+more1trk:
+	pushw	%ax			# save context
+	movb	$2, %ah			# cmd: read chs
+        int     $0x13
+	xchgw	%ax, %bp		# status
+	popw	%si			# save %ax
+        popw    %ax			# limits
+	popw	%dx
+	jc	check_limits
+	xchgw	%ax, %bp
+update_regs:
+	incw	%cx			# next sector
+	movw	%cx, %gs
+	addb	$2,%bh			# next location
+	decw	%di			# update sector counter
+	jz	putcdot
+	decw	%si
+	jnz	update_regs
+read_sectors:
+	movw	%gs, %cx
+#   al is last sector+1
+#   ah is last cylinder+1
+	xchgw	%ax, %bp
+        cmpb    %al,%cl			# reach sector limit ?
+        jne     bdendlp
+next_head:
+        movb    %cl,%al
+        incb    %dh			# next head
+        movb    $1,%cl			# first sector
+        cmpb    %ah, %dh		# reach head limit ?
+        jne     bdendlp
+next_cylinder:
+        movb    %dh,%ah
+# NOTE : support 256 cylinders max
+        incb    %ch			# next cylinder
+        cmpb    $FLOPPY_CYLINDERS, %ch	# reach cylinder limit ?
+read_first_sectors:
+        movb    $0,%dh			# first head
+        jne	bdendlp
+next_floppy:
+	movb	$0,%ch			# first cylinder
+	pushaw
+	movw	$swap_floppy,%si
+	incb	12(%si)
+	pushw	%bx
+	call	puts
+	popw	%bx
+waitfloppy:
+	call	wait
+	jne	waitfloppydone
+	pushw	%dx			# some bios break dx...
+	cbw
+	int	$0x13			# reset FDC
+	movw	$0x201,%ax
+	int	$0x13			# read first sector
+	popw	%dx
+	rclb	$1,%ah			# floppy changed 06=>0D no error 00
+	cmpb	-2(%si), %ah		# 0D then 00
+	jne	waitfloppy		# no => try again
+	incw	%si
+	orb	%ah,%ah			# was 00 ?
+	jne	waitfloppy
+waitfloppydone:
+	popaw
+bdendlp:
+        jmp	read_sectorslp
+
+putcdot:
+# REMOVE ME START
+# pushw	%ss
+# popw	%es
+# REMOVE ME STOP
+	movb	$0x2e+3, %al 		# loading... message 2e = .
+putclf:
+	subb	$3, %al
+putc:
+	movb	$0xe, %ah
+	movw	$7, %bx			#   one dot each 64k
+ 	int	$0x10
+	cmp	$0xd, %al		# CR ?
+	je	putclf
+	ret
+
+puts:
+	movb	$0xd, %al		# CR
+putcs:
+	call	putc
+	lodsb
+	orb	%al,%al			# end of string is \0
+	jnz	putcs
+	ret
+
+clock	= 0x46C
+wait:
+wait4key:
+	movw	$clock, %di
+#define DELAY 5
+	movb	$(DELAY*182)/10,%cl
+	addb	%fs:(%di),%cl
+waitkbd:
+	movw	$0x10D, %ax		# test keyboard, timeout => CR
+	cmpb	%fs:(%di),%cl
+	je	waitdone
+	int	$0x16
+	jz	waitkbd
+	cbw
+	int	$0x16			# eat char
+	movw	%di, %fs		# disable timeout
+	incw	%di			# clear Z
+waitdone:
+	ret
+
+regs:	.asciz	"X:"
+
+swap_floppy:	.ascii	"Insert disk 1"
+		.byte	7,13,0
 
 	# Kernel attributes; used by setup.  This is part 1 of the
 	# header, from the old boot sector.
